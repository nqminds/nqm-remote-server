{
  "name": "minimongo",
  "version": "3.5.6",
  "description": "Client-side mongo database with server sync over http",
  "main": "index.js",
  "scripts": {
    "test": "testem ci",
    "prepublish": "gulp"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mWater/minimongo.git"
  },
  "keywords": [
    "mongodb",
    "mongo",
    "minimongo",
    "IndexedDb",
    "WebSQL",
    "storage"
  ],
  "author": {
    "name": "Clayton Grassick"
  },
  "license": "LGPLv3",
  "bugs": {
    "url": "https://github.com/mWater/minimongo/issues"
  },
  "homepage": "https://github.com/mWater/minimongo",
  "devDependencies": {
    "browserify": "^3.29.1",
    "chai": "~1.9.0",
    "coffee-script": "~1.6.3",
    "coffeeify": "~0.6.0",
    "glob": "^3.2.9",
    "gulp": "^3.8.11",
    "gulp-coffee": "^1.4.2",
    "gulp-rename": "^1.2.0",
    "gulp-uglify": "^0.3.1",
    "gulp-util": "^2.2.14",
    "karma": "^0.13.10",
    "karma-browserify": "^4.3.0",
    "karma-chrome-launcher": "^0.2.0",
    "karma-mocha": "^0.2.0",
    "sinon": "~1.8.2",
    "testem": "~0.6.7",
    "vinyl-buffer": "0.0.0",
    "vinyl-source-stream": "^0.1.1"
  },
  "dependencies": {
    "async": "^0.8.0",
    "bowser": "^0.7.1",
    "idb-wrapper": "^1.4.1",
    "jquery": "~2.1.0",
    "lodash": "~2.4.1"
  },
  "gitHead": "fa0b297b79e1726f5ce5b280075cac224b688654",
  "readme": "# Minimongo\r\n\r\nA client-side MongoDB implementation which supports basic queries, including some geospatial ones.\r\n\r\nUses code from Meteor.js minimongo package, reworked to support more geospatial queries and made npm+browserify friendly. It was forked in January 2014.\r\n\r\nIt is either IndexedDb backed (IndexedDb), WebSQL backed (WebSQLDb), Local storage backed (LocalStorageDb) or in memory only (MemoryDb).\r\n\r\nAutoselection is possible with utils.autoselectLocalDb(options, success, error)\r\n\r\n## Usage\r\n\r\nMinimongo is designed to be used with browserify.\r\n\r\n```javascript\r\n\r\n// Require minimongo\r\nvar minimongo = require(\"minimongo\");\r\n\r\nvar LocalDb = minimongo.MemoryDb;\r\n\r\n// Create local db (in memory database with no backing)\r\ndb = new LocalDb();\r\n\r\n// Add a collection to the database\r\ndb.addCollection(\"animals\");\r\n\r\ndoc = { species: \"dog\", name: \"Bingo\" };\r\n\r\n// Always use upsert for both inserts and modifies\r\ndb.animals.upsert(doc, function() {\r\n\t// Success:\r\n\r\n\t// Query dog (with no query options beyond a selector)\r\n\tdb.animals.findOne({ species:\"dog\" }, {}, function(res) {\r\n\t\tconsole.log(\"Dog's name is: \" + res.name);\r\n\t});\r\n});\r\n```\r\n\r\n### Upserting\r\n\r\n`db.sometable.upsert(docs, bases, success, error)` can take either a single document or multiple documents (array) for the first and second parameter.\r\n\r\ndocs is the document(s) to upsert. If bases is present, it is the base version on which the update is based. It can be omitted to use the current cached value\r\nas the base, or put as `null` to force an overwrite (a true upsert, not a patch)\r\n\r\n### Resolving upserts\r\n\r\nUpserts are stored in local databases in a special state to record that they are upserts, not cached rows. The base document on which the upsert is based is also stored. For example, if a row starts in cached state with `{ x:1 }` and is upserted to `{ x: 2 }`, both the upserted and the original state are stored. This allows the server to do 3-way merging and apply only the changes.\r\n\r\nTo resolve the upsert (for example once sent to central db), use resolveUpserts on collection\r\n\r\n`db.sometable.resolveUpserts(upserts, success, error)` takes the list of upserts to resolve\r\n\r\n`resolveUpserts` does not resolve an upsert if another upsert on the same row has taken place. Instead, the base value is updated (since the change has been accepted by the server) but the new upserted value is left alone.\r\n\r\n### IndexedDb\r\n\r\nTo make a database backed by IndexedDb:\r\n\r\n```javascript\r\n\r\n// Require minimongo\r\nvar minimongo = require(\"minimongo\");\r\n\r\nvar IndexedDb = minimongo.IndexedDb;\r\n\r\n// Create IndexedDb\r\ndb = new IndexedDb({namespace: \"mydb\"}, function() {\r\n\t// Add a collection to the database\r\n\tdb.addCollection(\"animals\", function() {\r\n\t\tdoc = { species: \"dog\", name: \"Bingo\" };\r\n\r\n\t\t// Always use upsert for both inserts and modifies\r\n\t\tdb.animals.upsert(doc, function() {\r\n\t\t\t// Success:\r\n\r\n\t\t\t// Query dog (with no query options beyond a selector)\r\n\t\t\tdb.animals.findOne({ species:\"dog\" }, {}, function(res) {\r\n\t\t\t\tconsole.log(\"Dog's name is: \" + res.name);\r\n\t\t\t});\r\n\t\t});\r\n\t});\r\n}, function() { alert(\"some error!\"); });\r\n\r\n```\r\n\r\n### Caching\r\n\r\nRows can be cached without creating a pending upsert. This is done automatically when HybridDb uploads to a remote database with the returned upserted rows. It is also done when a query is performed on HybridDb: the results are cached in the local db and the query is re-performed on the local database.\r\n\r\nThe field `_rev`, if present is used to prevent overwriting with older versions. This is the odd scenario where an updated version of a row is present, but an older query to the server is delayed in returning. To prevent this race condition from giving stale data, the _rev field is used.\r\n\r\n### HybridDb\r\n\r\nCombines results from the local database with remote data. Multiple options can be specified at the collection level and then overriden at the find/findOne level:\r\n\r\n**interim**: (default true) true to return interim results from the local database before the (slower) remote database has returned. If the remote database gives different results, the callback will be called a second time. This approach allows fast responses but with subsequent correction if the server has differing information.\r\n\r\n**cacheFind**: (default true) true to cache the `find` results from the remote database in the local database\r\n\r\n**cacheFindOne**: (default true) true to cache the `findOne` results from the remote database in the local database\r\n\r\n**shortcut**: (default false) true to return `findOne` results if any matching result is found in the local database. Useful for documents that change rarely.\r\n\r\n**useLocalOnRemoteError**: (default true) true to use local results if the remote find fails. Only applies if interim is false.\r\n\r\n\r\nTo keep a local database and a remote database in sync, create a HybridDb:\r\n\r\n```\r\nhybridDb = new HybridDb(localDb, remoteDb)\r\n```\r\n\r\nBe sure to add the same collections to all three databases (local, hybrid and remote).\r\n\r\nThen query the hybridDb (`find` and `findOne`) to have it get results and correctly combine them with any pending local results. If you are not interested in caching results, add `{ cacheFind: false, cacheFindOne: false }` to the options of `find` or `findOne` or to the `addCollection` options.\r\n\r\nWhen upserts and removes are done on the HybridDb, they are queued up in the LocalDb until `hybridDb.upload(success, error)` is called.\r\n\r\n`upload` will go through each collection and send any upserts or removes to the remoteDb.\r\n\r\n`findOne` will not return an interim `null` result, but will only return interim results when one is present.\r\n\r\n### RemoteDb\r\n\r\nUses AJAX-JSON calls to an API to query a real Mongo database. API is simple and contains only query, upsert, patch and remove commands.\r\n\r\nIf the `client` field is passed to the constructor, it is appended as a query parameters (e.g. `?client=1234`) to each request made.\r\n\r\nExample code:\r\n\r\n```\r\nremoteDb = new minimongo.RemoteDb(\"http://someserver.com/api/\", \"myclientid123\")\r\n```\r\n\r\nThis would create a remote db that would make the following call to the api for a find to collection abc:\r\n\r\n`GET http://someserver.com/api/abc?client=myclientid123`\r\n\r\nThe client is optional and is a string that is passed in each call only to make authentication easier.\r\n\r\nThe API that RemoteDb should support four HTTP methods for each collection:\r\n\r\n#### GET `/<collection>`\r\n\r\nPerforms a query, returning an array of results. GET query parameters are:\r\n\r\n**selector** (optional) : JSON of query, in MongoDB format. e.g. `{\"a\": 1}` to find records with field `a` having value `1`\r\n**fields** (optional) : JSON object indicating which fields to return in MongoDB format. e.g. `{\"a\": 1}` to return only field `a` and `_id`\r\n**sort** (optional) : JSON of MongoDB sort field. e.g. `[\"a\"]` to sort ascending by `a`, or `[[\"a\",\"desc\"]]` to sort descending by `a`\r\n**limit** (optional) : Maximum records to return e.g. `100`\r\n\r\nPossible HTTP response codes:\r\n\r\n**200** : normal response\r\n**401** : client was invalid\r\n\r\n#### POST `/<collection>`\r\n\r\nPerforms a single upsert, returning the upserted row. POST value is the document to upsert. Possible HTTP response codes:\r\n\r\n**200** : document was upserted. Returns the upserted object (see notes below on merging)\r\n**400** : document did not pass validation\r\n**401** : client was invalid or not present\r\n**403** : permission denied to upsert\r\n**409** : another client was upserting same document. Try again.\r\n**410** : document was already removed and cannot be upserted\r\n\r\nOn `403` or `410`, the change is automatically discarded in the HybridDb.\r\n\r\n#### PATCH `/<collection>/<_id>`\r\n\r\nPerforms a patch, returning the upserted row. PATCH value is the following structure:\r\n\r\n```\r\n{\r\n\tdoc: <the document in its new form>\r\n\tbase: <base document on which the changes were made>\r\n}\r\n```\r\n\r\nFor example, to change `{ x:1, y:1 }` to set x to be 2, PATCH would send\r\n```\r\n{\r\n\tdoc: { x:2, y: 1 }\r\n\tbase: { x:1, y: 1 }\r\n}\r\n```\r\n\r\nPossible HTTP response codes:\r\n\r\n**200** : document was upserted. Returns the upserted object\r\n**400** : document did not pass validation\r\n**401** : client was invalid or not present\r\n**403** : permission denied to upsert\r\n**409** : another client was upserting same document. Try again.\r\n**410** : document was already removed and cannot be upserted\r\n\r\nOn `403` or `410`, the change is automatically discarded in the HybridDb.\r\n\r\n#### DELETE `/<collection>/<_id>`\r\n\r\nRemoves a document. _id of the document to remove\r\n\r\n**200** : document was removed\r\n**401** : client was invalid or not present\r\n**403** : permission denied to remove\r\n**410** : document was already removed and cannot be removed again\r\n\r\nOn `403` or `410`, the change is automatically discarded in the HybridDb.\r\n\r\n### Merging\r\n\r\nMinimongo is designed to work with a server that performs three-way merging of documents that are being upserted by multiple users.\r\n\r\nIt can also be used with a simple server that just overwrites documents completely on upsert, just taking the doc value of PATCH, though this is not recommended.\r\n\r\n## Testing\r\n\r\nTo test, run `testem` in the main directory.\r\n\r\nTo test a RemoteDb implementation, use `test/RemoteDbTests.coffee`. Server must have a collection called scratch with fields as specified at top of tests file.\r\n",
  "readmeFilename": "README.md",
  "_id": "minimongo@3.5.6",
  "_shasum": "b175842ae2838456cb2d0dc68971251519974f17",
  "_from": "git://github.com/nqminds/minimongo.git",
  "_resolved": "git://github.com/nqminds/minimongo.git#fa0b297b79e1726f5ce5b280075cac224b688654"
}
