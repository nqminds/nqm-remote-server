/**
 * Modules in this bundle
 * @license
 * 
 * espower:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   contributors: James Talmage
 *   homepage: http://github.com/power-assert-js/espower
 *   version: 1.2.1
 * 
 * amdefine:
 *   license: BSD-3-Clause AND MIT
 *   author: James Burke <jrburke@gmail.com>
 *   maintainers: jrburke <jrburke@gmail.com>
 *   homepage: http://github.com/jrburke/amdefine
 *   version: 1.0.0
 * 
 * array-filter:
 *   license: MIT
 *   author: Julian Gruber <mail@juliangruber.com>
 *   maintainers: juliangruber <julian@juliangruber.com>
 *   homepage: https://github.com/juliangruber/array-filter
 *   version: 1.0.0
 * 
 * array-foreach:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/array-foreach
 *   version: 1.0.1
 * 
 * array-map:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/array-map
 *   version: 0.0.0
 * 
 * array-reduce:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/array-reduce
 *   version: 0.0.0
 * 
 * deep-equal:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/node-deep-equal#readme
 *   version: 1.0.1
 * 
 * escallmatch:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/twada/escallmatch
 *   version: 1.4.2
 * 
 * escodegen:
 *   license: BSD-2-Clause
 *   maintainers: constellation <utatane.tea@gmail.com>, michaelficarra <npm@michael.ficarra.me>
 *   homepage: http://github.com/estools/escodegen
 *   version: 1.7.0
 * 
 * esprima:
 *   license: BSD-2-Clause
 *   author: Ariya Hidayat <ariya.hidayat@gmail.com>
 *   maintainers: ariya <ariya.hidayat@gmail.com>
 *   homepage: http://esprima.org
 *   version: 2.7.0
 * 
 * espurify:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   homepage: https://github.com/estools/espurify
 *   version: 1.3.0
 * 
 * estraverse:
 *   license: BSD-2-Clause
 *   maintainers: constellation <utatane.tea@gmail.com>, michaelficarra <npm@michael.ficarra.me>, nzakas <nicholas@nczconsulting.com>
 *   homepage: https://github.com/estools/estraverse
 *   version: 4.1.1
 * 
 * esutils:
 *   licenses: BSD
 *   maintainers: constellation <utatane.tea@gmail.com>, michaelficarra <npm@michael.ficarra.me>
 *   homepage: https://github.com/estools/esutils
 *   version: 2.0.2
 * 
 * indexof:
 *   maintainers: tjholowaychuk <tj@vision-media.ca>
 *   version: 0.0.1
 * 
 * is-url:
 *   license: MIT
 *   maintainers: segmentio <friends@segment.io>, zeke <zeke@sikelianos.com>
 *   homepage: https://github.com/segmentio/is-url
 *   version: 1.2.1
 * 
 * isarray:
 *   license: MIT
 *   author: Julian Gruber <mail@juliangruber.com>
 *   maintainers: juliangruber <julian@juliangruber.com>
 *   homepage: https://github.com/juliangruber/isarray
 *   version: 0.0.1
 * 
 * object-keys:
 *   license: MIT
 *   author: Jordan Harband <ljharb@gmail.com>
 *   maintainers: ljharb <ljharb@gmail.com>
 *   contributors: Jordan Harband <ljharb@gmail.com>, Raynos <raynos2@gmail.com>, Nathan Rajlich <nathan@tootallnate.net>, Ivan Starkov <istarkov@gmail.com>, Gary Katsevman <git@gkatsev.com>
 *   homepage: https://github.com/ljharb/object-keys#readme
 *   version: 1.0.9
 * 
 * path-browserify:
 *   license: MIT
 *   author: James Halliday <mail@substack.net>
 *   maintainers: substack <mail@substack.net>
 *   homepage: https://github.com/substack/path-browserify
 *   version: 0.0.0
 * 
 * path-is-absolute:
 *   license: MIT
 *   author: Sindre Sorhus <sindresorhus@gmail.com>
 *   maintainers: sindresorhus <sindresorhus@gmail.com>
 *   homepage: https://github.com/sindresorhus/path-is-absolute
 *   version: 1.0.0
 * 
 * process:
 *   license: MIT
 *   author: Roman Shtylman <shtylman@gmail.com>
 *   maintainers: coolaj86 <coolaj86@gmail.com>, defunctzombie <shtylman@gmail.com>
 *   homepage: https://github.com/shtylman/node-process#readme
 *   version: 0.11.2
 * 
 * source-map:
 *   license: BSD-3-Clause
 *   author: Nick Fitzgerald <nfitzgerald@mozilla.com>
 *   maintainers: mozilla-devtools <mozilla-developer-tools@googlegroups.com>, mozilla <dherman@mozilla.com>, nickfitzgerald <fitzgen@gmail.com>
 *   contributors: Tobias Koppers <tobias.koppers@googlemail.com>, Duncan Beevers <duncan@dweebd.com>, Stephen Crane <scrane@mozilla.com>, Ryan Seddon <seddon.ryan@gmail.com>, Miles Elam <miles.elam@deem.com>, Mihai Bazon <mihai.bazon@gmail.com>, Michael Ficarra <github.public.email@michael.ficarra.me>, Todd Wolfson <todd@twolfson.com>, Alexander Solovyov <alexander@solovyov.net>, Felix Gnass <fgnass@gmail.com>, Conrad Irwin <conrad.irwin@gmail.com>, usrbincc <usrbincc@yahoo.com>, David Glasser <glasser@davidglasser.net>, Chase Douglas <chase@newrelic.com>, Evan Wallace <evan.exe@gmail.com>, Heather Arthur <fayearthur@gmail.com>, Hugh Kennedy <hughskennedy@gmail.com>, David Glasser <glasser@davidglasser.net>, Simon Lydell <simon.lydell@gmail.com>, Jmeas Smith <jellyes2@gmail.com>, Michael Z Goddard <mzgoddard@gmail.com>, azu <azu@users.noreply.github.com>, John Gozde <john@gozde.ca>, Adam Kirkton <akirkton@truefitinnovation.com>, Chris Montgomery <christopher.montgomery@dowjones.com>, J. Ryan Stinnett <jryans@gmail.com>, Jack Herrington <jherrington@walmartlabs.com>, Chris Truter <jeffpalentine@gmail.com>, Daniel Espeset <daniel@danielespeset.com>, Jamie Wong <jamie.lf.wong@gmail.com>, Eddy Bruël <ejpbruel@mozilla.com>, Hawken Rives <hawkrives@gmail.com>, Gilad Peleg <giladp007@gmail.com>, djchie <djchie.dev@gmail.com>, Gary Ye <garysye@gmail.com>, Nicolas Lalevée <nicolas.lalevee@hibnet.org>
 *   homepage: https://github.com/mozilla/source-map
 *   version: 0.5.3
 * 
 * type-name:
 *   license: MIT
 *   author: Takuto Wada <takuto.wada@gmail.com>
 *   contributors: azu, Yosuke Furukawa
 *   homepage: https://github.com/twada/type-name
 *   version: 1.1.0
 * 
 * xtend:
 *   license: MIT
 *   author: Raynos <raynos2@gmail.com>
 *   maintainers: raynos <raynos2@gmail.com>
 *   contributors: Jake Verbaten, Matt Esch
 *   homepage: https://github.com/Raynos/xtend
 *   version: 4.0.1
 * 
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.espower = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * espower - Power Assert feature instrumentor based on the ECMAScript AST.
 *
 * https://github.com/power-assert-js/espower
 *
 * Copyright (c) 2013-2015 Takuto Wada
 * Licensed under the MIT license.
 *   https://github.com/power-assert-js/espower/blob/master/MIT-LICENSE.txt
 */
'use strict';

var defaultOptions = _dereq_('./lib/default-options');
var Instrumentor = _dereq_('./lib/instrumentor');
var extend = _dereq_('xtend');

/**
 * Instrument power assert feature into code. ECMAScript AST in, ECMAScript AST out.
 * @param {object} originalAst JavaScript ECMAScript JS AST to instrument (directly modified if destructive option is truthy)
 * @param {object} options Instrumentation options.
 * @returns {object} instrumented AST
 * @throws {EspowerError} if `originalAst` is already instrumented
 * @throws {EspowerError} if `originalAst` does not contain location information
 * @throws {EspowerError} if `options` is not valid
 */
function espower (originalAst, options) {
    var instrumentor = new Instrumentor(extend(defaultOptions(), options));
    return instrumentor.instrument(originalAst);
}

espower.defaultOptions = defaultOptions;
espower.Instrumentor = Instrumentor;
espower.AssertionVisitor = _dereq_('./lib/assertion-visitor');
espower.EspowerError = _dereq_('./lib/espower-error');
module.exports = espower;

},{"./lib/assertion-visitor":2,"./lib/default-options":4,"./lib/espower-error":5,"./lib/instrumentor":6,"xtend":65}],2:[function(_dereq_,module,exports){
'use strict';

var estraverse = _dereq_('estraverse');
var escodegen = _dereq_('escodegen');
var espurify = _dereq_('espurify');
var espurifyWithRaw = espurify.customize({extra: 'raw'});
var isArray = _dereq_('isarray');
var deepEqual = _dereq_('deep-equal');
var syntax = estraverse.Syntax;
var SourceMapConsumer = _dereq_('source-map').SourceMapConsumer;
var EspowerError = _dereq_('./espower-error');
var toBeSkipped = _dereq_('./rules/to-be-skipped');
var toBeCaptured = _dereq_('./rules/to-be-captured');
var canonicalCodeOptions = {
    format: {
        indent: {
            style: ''
        },
        newline: ''
    },
    verbatim: 'x-verbatim-espower'
};
var _path = _dereq_('path');
var isAbsolute = _dereq_('path-is-absolute');
var isUrl = _dereq_('is-url');

function astEqual (ast1, ast2) {
    return deepEqual(espurify(ast1), espurify(ast2));
}

function AssertionVisitor (matcher, assertionPath, enclosingFunc, options) {
    this.matcher = matcher;
    this.assertionPath = [].concat(assertionPath);
    this.options = options || {};
    if (this.options.sourceMap) {
        this.sourceMapConsumer = new SourceMapConsumer(this.options.sourceMap);
    }
    this.currentArgumentPath = null;
    this.argumentModified = false;
    this.withinGenerator = enclosingFunc && enclosingFunc.generator;
    this.withinAsync = enclosingFunc && enclosingFunc.async;
}

AssertionVisitor.prototype.enter = function (currentNode, parentNode) {
    this.canonicalCode = this.generateCanonicalCode(currentNode);
    this.powerAssertCalleeObject = this.guessPowerAssertCalleeObjectFor(currentNode.callee);

    if (this.sourceMapConsumer) {
        var pos = this.sourceMapConsumer.originalPositionFor({
            line: currentNode.loc.start.line,
            column: currentNode.loc.start.column
        });
        if (pos) {
            // console.log(JSON.stringify(pos, null, 2));
            if (pos.source) {
                if (this.sourceMapConsumer.sourceRoot && isUrl(this.sourceMapConsumer.sourceRoot)) {
                    this.filepath = _path.relative(this.sourceMapConsumer.sourceRoot, pos.source);
                } else if (this.options.sourceRoot && isAbsolute(this.options.sourceRoot) && isAbsolute(pos.source)) {
                    this.filepath = _path.relative(this.options.sourceRoot, pos.source);
                } else if (this.sourceMapConsumer.sourceRoot && isAbsolute(this.sourceMapConsumer.sourceRoot) && isAbsolute(pos.source)) {
                    this.filepath = _path.relative(this.sourceMapConsumer.sourceRoot, pos.source);
                } else if (isUrl(pos.source)) {
                    this.filepath = _path.basename(pos.source);
                } else {
                    this.filepath = pos.source;
                }
            }
            if (pos.line) {
                this.lineNum = pos.line;
            }
        }
    }

    if (!this.filepath) {
        if (this.options.sourceRoot && isAbsolute(this.options.sourceRoot) && isAbsolute(this.options.path)) {
            this.filepath = _path.relative(this.options.sourceRoot, this.options.path);
        } else {
            this.filepath = this.options.path;
        }
    }

    this.filepath = fallbackOnBasename(this.filepath);

    if (!this.lineNum) {
        this.lineNum = currentNode.loc.start.line;
    }
};

AssertionVisitor.prototype.leave = function (currentNode, parentNode) {
    // nothing to do now
};

AssertionVisitor.prototype.verifyNotInstrumented = function (currentNode) {
    if (currentNode.type !== syntax.CallExpression) {
        return;
    }
    if (currentNode.callee.type !== syntax.MemberExpression) {
        return;
    }
    var prop = currentNode.callee.property;
    if (prop.type === syntax.Identifier && prop.name === '_expr') {
        if (astEqual(currentNode.callee.object, this.powerAssertCalleeObject)) {
            var errorMessage = 'Attempted to transform AST twice.';
            if (this.options.path) {
                errorMessage += ' path: ' + this.options.path;
            }
            throw new EspowerError(errorMessage, this.verifyNotInstrumented);
        }
    }
};

AssertionVisitor.prototype.enterArgument = function (currentNode, parentNode, path) {
    var argMatchResult = this.matcher.matchArgument(currentNode, parentNode);
    if (argMatchResult) {
        if (argMatchResult.name === 'message' && argMatchResult.kind === 'optional') {
            // skip optional message argument
            return undefined;
        }
        this.verifyNotInstrumented(currentNode);
        // entering target argument
        this.currentArgumentPath = [].concat(path);
        return undefined;
    }
    return undefined;
};

AssertionVisitor.prototype.leaveArgument = function (resultTree) {
    this.currentArgumentPath = null;
    if (this.argumentModified) {
        this.argumentModified = false;
        return this.captureArgument(resultTree);
    } else {
        return resultTree;
    }
};

AssertionVisitor.prototype.isCapturingArgument = function () {
    return !!this.currentArgumentPath;
};

AssertionVisitor.prototype.isLeavingAssertion = function (nodePath) {
    return isPathIdentical(this.assertionPath, nodePath);
};

AssertionVisitor.prototype.isLeavingArgument = function (nodePath) {
    return isPathIdentical(this.currentArgumentPath, nodePath);
};

AssertionVisitor.prototype.captureArgument = function (node) {
    var n = newNodeWithLocationCopyOf(node);
    var props = [];
    var newCalleeObject = updateLocRecursively(espurify(this.powerAssertCalleeObject), n, this.options.visitorKeys);
    if (this.withinAsync) {
        addLiteralTo(props, n, 'async', true);
    }
    addLiteralTo(props, n, 'content', this.canonicalCode);
    addLiteralTo(props, n, 'filepath', this.filepath);
    if (this.withinGenerator) {
        addLiteralTo(props, n, 'generator', true);
    }
    addLiteralTo(props, n, 'line', this.lineNum);
    return n({
        type: syntax.CallExpression,
        callee: n({
            type: syntax.MemberExpression,
            computed: false,
            object: newCalleeObject,
            property: n({
                type: syntax.Identifier,
                name: '_expr'
            })
        }),
        arguments: [node].concat(n({
            type: syntax.ObjectExpression,
            properties: props
        }))
    });
};

AssertionVisitor.prototype.captureNode = function (target, path) {
    this.argumentModified = true;
    var n = newNodeWithLocationCopyOf(target);
    var relativeEsPath = path.slice(this.assertionPath.length);
    var newCalleeObject = updateLocRecursively(espurify(this.powerAssertCalleeObject), n, this.options.visitorKeys);
    return n({
        type: syntax.CallExpression,
        callee: n({
            type: syntax.MemberExpression,
            computed: false,
            object: newCalleeObject,
            property: n({
                type: syntax.Identifier,
                name: '_capt'
            })
        }),
        arguments: [
            target,
            n({
                type: syntax.Literal,
                value: relativeEsPath.join('/')
            })
        ]
    });
};

AssertionVisitor.prototype.toBeSkipped = function (currentNode, parentNode, currentKey) {
    return toBeSkipped(currentNode, parentNode, currentKey);
};

AssertionVisitor.prototype.toBeCaptured = function (currentNode, parentNode, currentKey) {
    return toBeCaptured(currentNode, parentNode, currentKey);
};

AssertionVisitor.prototype.generateCanonicalCode = function (node) {
    var visitorKeys = this.options.visitorKeys;
    var ast = espurifyWithRaw(node);
    var visitor = {
        leave: function (currentNode, parentNode) {
            if (currentNode.type === syntax.Literal && typeof currentNode.raw !== 'undefined') {
                currentNode['x-verbatim-espower'] = {
                    content : currentNode.raw,
                    precedence : escodegen.Precedence.Primary
                };
                return currentNode;
            } else {
                return undefined;
            }
        }
    };
    if (visitorKeys) {
        visitor.keys = visitorKeys;
    }
    estraverse.replace(ast, visitor);
    return escodegen.generate(ast, canonicalCodeOptions);
};

AssertionVisitor.prototype.guessPowerAssertCalleeObjectFor = function (node) {
    switch(node.type) {
    case syntax.Identifier:
        return node;
    case syntax.MemberExpression:
        return node.object; // Returns browser.assert when browser.assert.element(selector)
    }
    return null;
};

function fallbackOnBasename (filepath) {
    if (filepath) {
        if (filepath.split(_path.sep).indexOf('..') !== -1) {
            return _path.basename(filepath);
        } else if (isUrl(filepath)) {
            return _path.basename(filepath);
        } else if (isAbsolute(filepath)) {
            return _path.basename(filepath);
        }
    }
    return filepath;
}

function addLiteralTo (props, createNode, name, data) {
    if (data) {
        addToProps(props, createNode, name, createNode({
            type: syntax.Literal,
            value: data
        }));
    }
}

function addToProps (props, createNode, name, value) {
    props.push(createNode({
        type: syntax.Property,
        key: createNode({
            type: syntax.Identifier,
            name: name
        }),
        value: value,
        method: false,
        shorthand: false,
        computed: false,
        kind: 'init'
    }));
}

function updateLocRecursively (node, n, visitorKeys) {
    var visitor = {
        leave: function (currentNode, parentNode) {
            return n(currentNode);
        }
    };
    if (visitorKeys) {
        visitor.keys = visitorKeys;
    }
    estraverse.replace(node, visitor);
    return node;
}

function isPathIdentical (path1, path2) {
    if (!path1 || !path2) {
        return false;
    }
    return path1.join('/') === path2.join('/');
}

function newNodeWithLocationCopyOf (original) {
    return function (newNode) {
        if (typeof original.loc !== 'undefined') {
            var newLoc = {
                start: {
                    line: original.loc.start.line,
                    column: original.loc.start.column
                },
                end: {
                    line: original.loc.end.line,
                    column: original.loc.end.column
                }
            };
            if (typeof original.loc.source !== 'undefined') {
                newLoc.source = original.loc.source;
            }
            newNode.loc = newLoc;
        }
        if (isArray(original.range)) {
            newNode.range = [original.range[0], original.range[1]];
        }
        return newNode;
    };
}

module.exports = AssertionVisitor;

},{"./espower-error":5,"./rules/to-be-captured":8,"./rules/to-be-skipped":9,"deep-equal":13,"escodegen":23,"espurify":42,"estraverse":48,"is-url":50,"isarray":51,"path":11,"path-is-absolute":52,"source-map":63}],3:[function(_dereq_,module,exports){
/**
 * Copyright (C) 2012 Yusuke Suzuki (twitter: @Constellation) and other contributors.
 * Released under the BSD license.
 * https://github.com/Constellation/esmangle/blob/master/LICENSE.BSD
 */
'use strict';

var isArray = _dereq_('isarray');

function deepCopyInternal (obj, result) {
    var key, val;
    for (key in obj) {
        if (key.lastIndexOf('_', 0) === 0) {
            continue;
        }
        if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === 'object' && val !== null) {
                if (val instanceof RegExp) {
                    val = new RegExp(val);
                } else {
                    val = deepCopyInternal(val, isArray(val) ? [] : {});
                }
            }
            result[key] = val;
        }
    }
    return result;
}

function deepCopy (obj) {
    return deepCopyInternal(obj, isArray(obj) ? [] : {});
}

module.exports = deepCopy;

},{"isarray":51}],4:[function(_dereq_,module,exports){
'use strict';

module.exports = function defaultOptions () {
    return {
        destructive: false,
        patterns: [
            'assert(value, [message])',
            'assert.ok(value, [message])',
            'assert.equal(actual, expected, [message])',
            'assert.notEqual(actual, expected, [message])',
            'assert.strictEqual(actual, expected, [message])',
            'assert.notStrictEqual(actual, expected, [message])',
            'assert.deepEqual(actual, expected, [message])',
            'assert.notDeepEqual(actual, expected, [message])',
            'assert.deepStrictEqual(actual, expected, [message])',
            'assert.notDeepStrictEqual(actual, expected, [message])'
        ]
    };
};

},{}],5:[function(_dereq_,module,exports){
'use strict';

function EspowerError (message, stackStartFunction) {
    if (Error.captureStackTrace) { // V8
        Error.captureStackTrace(this, stackStartFunction);
    } else {
        var _err = new Error();
        var _stack = _err.stack;
        if (!_stack) {  // IE10
            try {
                throw _err;
            } catch (e) {
                _stack = e.stack;
            }
        }
        this.stack = _stack;
    }
    this.message = '[espower] ' + message;
}
EspowerError.prototype = Object.create(Error.prototype);
EspowerError.prototype.constructor = EspowerError;
EspowerError.prototype.name = 'EspowerError';

module.exports = EspowerError;

},{}],6:[function(_dereq_,module,exports){
'use strict';

var estraverse = _dereq_('estraverse');
var syntax = estraverse.Syntax;
var escallmatch = _dereq_('escallmatch');
var cloneAst = _dereq_('./clone-ast');
var AssertionVisitor = _dereq_('./assertion-visitor');
var EspowerError = _dereq_('./espower-error');
var typeName = _dereq_('type-name');

function Instrumentor (options) {
    verifyOptionPrerequisites(options);
    this.options = options;
    this.matchers = options.patterns.map(function (pattern) { return escallmatch(pattern, options); });
}

Instrumentor.prototype.instrument = function (ast) {
    verifyAstPrerequisites(ast, this.options);
    var that = this;
    var assertionVisitor;
    var skipping = false;
    var result = (this.options.destructive) ? ast : cloneAst(ast);
    var visitor = {
        enter: function (currentNode, parentNode) {
            var controller = this;
            var path = controller.path();
            var currentKey = path ? path[path.length - 1] : null;
            if (assertionVisitor) {
                if (assertionVisitor.toBeSkipped(currentNode, parentNode, currentKey)) {
                    skipping = true;
                    return controller.skip();
                }
                if (!assertionVisitor.isCapturingArgument() && !isCalleeOfParentCallExpression(parentNode, currentKey)) {
                    return assertionVisitor.enterArgument(currentNode, parentNode, path);
                }
            } else if (currentNode.type === syntax.CallExpression) {
                var candidates = that.matchers.filter(function (matcher) { return matcher.test(currentNode); });
                if (candidates.length === 1) {
                    // entering target assertion
                    var enclosingFunc = findEnclosingFunction(controller.parents());
                    assertionVisitor = new AssertionVisitor(candidates[0], path, enclosingFunc, that.options);
                    assertionVisitor.enter(currentNode, parentNode);
                    return undefined;
                }
            }
            return undefined;
        },
        leave: function (currentNode, parentNode) {
            var path = this.path();
            var resultTree = currentNode;
            var currentKey = path ? path[path.length - 1] : null;
            if (!assertionVisitor) {
                return undefined;
            }
            if (skipping) {
                skipping = false;
                return undefined;
            }
            if (assertionVisitor.isLeavingAssertion(path)) {
                assertionVisitor.leave(currentNode, parentNode);
                assertionVisitor = null;
                return undefined;
            }
            if (!assertionVisitor.isCapturingArgument()) {
                return undefined;
            }
            if (assertionVisitor.toBeCaptured(currentNode, parentNode, currentKey)) {
                resultTree = assertionVisitor.captureNode(currentNode, path);
            }
            if (assertionVisitor.isLeavingArgument(path)) {
                return assertionVisitor.leaveArgument(resultTree);
            }
            return resultTree;
        }
    };
    if (this.options.visitorKeys) {
        visitor.keys = this.options.visitorKeys;
    }
    estraverse.replace(result, visitor);
    return result;
};

function isCalleeOfParentCallExpression (parentNode, currentKey) {
    return parentNode.type === syntax.CallExpression && currentKey === 'callee';
}

function isFunction(node) {
    return [
          syntax.FunctionDeclaration,
          syntax.FunctionExpression,
          syntax.ArrowFunctionExpression
      ].indexOf(node.type) !== -1;
}

function findEnclosingFunction(parents) {
    for (var i = parents.length - 1; i >= 0; i--) {
        if (isFunction(parents[i])) {
            return parents[i];
        }
    }
    return null;
}

function verifyAstPrerequisites (ast, options) {
    var errorMessage;
    if (typeof ast.loc === 'undefined') {
        errorMessage = 'ECMAScript AST should contain location information.';
        if (options.path) {
            errorMessage += ' path: ' + options.path;
        }
        throw new EspowerError(errorMessage, verifyAstPrerequisites);
    }
}

function verifyOptionPrerequisites (options) {
    if (typeName(options.destructive) !== 'boolean') {
        throw new EspowerError('options.destructive should be a boolean value.', verifyOptionPrerequisites);
    }
    if (typeName(options.patterns) !== 'Array') {
        throw new EspowerError('options.patterns should be an array.', verifyOptionPrerequisites);
    }
}

module.exports = Instrumentor;

},{"./assertion-visitor":2,"./clone-ast":3,"./espower-error":5,"escallmatch":16,"estraverse":48,"type-name":64}],7:[function(_dereq_,module,exports){
'use strict';

var estraverse = _dereq_('estraverse');
var syntax = estraverse.Syntax;

module.exports = [
    syntax.Identifier,
    syntax.MemberExpression,
    syntax.CallExpression,
    syntax.UnaryExpression,
    syntax.BinaryExpression,
    syntax.LogicalExpression,
    syntax.AssignmentExpression,
    syntax.ObjectExpression,
    syntax.NewExpression,
    syntax.ArrayExpression,
    syntax.ConditionalExpression,
    syntax.UpdateExpression,
    syntax.TemplateLiteral,
    syntax.TaggedTemplateExpression,
    syntax.SpreadElement,
    syntax.YieldExpression,
    syntax.AwaitExpression,
    syntax.Property
];

},{"estraverse":48}],8:[function(_dereq_,module,exports){
'use strict';

var estraverse = _dereq_('estraverse');
var syntax = estraverse.Syntax;
var caputuringTargetTypes = [
    // syntax.Property,
    syntax.ObjectExpression,
    syntax.ArrayExpression,
    // syntax.ConditionalExpression,
    syntax.Identifier,
    syntax.MemberExpression,
    syntax.CallExpression,
    syntax.UnaryExpression,
    syntax.BinaryExpression,
    syntax.LogicalExpression,
    syntax.AssignmentExpression,
    syntax.NewExpression,
    syntax.UpdateExpression,
    syntax.YieldExpression,
    syntax.AwaitExpression,
    syntax.TemplateLiteral,
    syntax.TaggedTemplateExpression
];

function isCaputuringTargetType (currentNode) {
    return caputuringTargetTypes.indexOf(currentNode.type) !== -1;
}

function isCalleeOfParent(parentNode, currentKey) {
    return (parentNode.type === syntax.CallExpression || parentNode.type === syntax.NewExpression) && currentKey === 'callee';
}

function isChildOfTaggedTemplateExpression(parentNode) {
    return parentNode.type === syntax.TaggedTemplateExpression;
}

function isYieldOrAwaitArgument(parentNode, currentKey) {
    // capture the yielded/await result, not the promise
    return (parentNode.type === syntax.YieldExpression || parentNode.type === syntax.AwaitExpression) && currentKey === 'argument';
}

module.exports = function toBeCaptured (currentNode, parentNode, currentKey) {
    return isCaputuringTargetType(currentNode) &&
        !isYieldOrAwaitArgument(parentNode, currentKey) &&
        !isCalleeOfParent(parentNode, currentKey) &&
        !isChildOfTaggedTemplateExpression(parentNode);
};

},{"estraverse":48}],9:[function(_dereq_,module,exports){
'use strict';

var estraverse = _dereq_('estraverse');
var syntax = estraverse.Syntax;
var supportedNodeTypes = _dereq_('./supported-node-types');

function isLeftHandSideOfAssignment(parentNode, currentKey) {
    // Do not instrument left due to 'Invalid left-hand side in assignment'
    return parentNode.type === syntax.AssignmentExpression && currentKey === 'left';
}

function isChildOfObjectLiteral (parentNode) {
    return parentNode.type === syntax.Property && parentNode.kind === 'init';
}

function isObjectLiteralKey (parentNode, currentKey) {
    return isChildOfObjectLiteral(parentNode) && currentKey === 'key';
}

function isObjectLiteralValue (parentNode, currentKey) {
    return isChildOfObjectLiteral(parentNode) && currentKey === 'value';
}

function isNonComputedObjectLiteralKey(parentNode, currentKey) {
    // Do not instrument non-computed Object literal key
    return isObjectLiteralKey(parentNode, currentKey) && !parentNode.computed;
}

function isShorthandedValueOfObjectLiteral(parentNode, currentKey) {
    // Do not instrument shorthanded Object literal value
    return isObjectLiteralValue(parentNode, currentKey) && parentNode.shorthand;
}

function isUpdateExpression(parentNode) {
    // Just wrap UpdateExpression, not digging in.
    return parentNode.type === syntax.UpdateExpression;
}

function isCallExpressionWithNonComputedMemberExpression(currentNode, parentNode, currentKey) {
    // Do not instrument non-computed property of MemberExpression within CallExpression.
    return currentNode.type === syntax.Identifier && parentNode.type === syntax.MemberExpression && !parentNode.computed && currentKey === 'property';
}

function isTypeOfOrDeleteUnaryExpression(currentNode, parentNode, currentKey) {
    // 'typeof Identifier' or 'delete Identifier' is not instrumented
    return currentNode.type === syntax.Identifier && parentNode.type === syntax.UnaryExpression && (parentNode.operator === 'typeof' || parentNode.operator === 'delete') && currentKey === 'argument';
}

function isSupportedNodeType (node) {
    return supportedNodeTypes.indexOf(node.type) !== -1;
}

module.exports = function toBeSkipped (currentNode, parentNode, currentKey) {
    return !isSupportedNodeType(currentNode) ||
        isLeftHandSideOfAssignment(parentNode, currentKey) ||
        isNonComputedObjectLiteralKey(parentNode, currentKey) ||
        isShorthandedValueOfObjectLiteral(parentNode, currentKey) ||
        isUpdateExpression(parentNode) ||
        isCallExpressionWithNonComputedMemberExpression(currentNode, parentNode, currentKey) ||
        isTypeOfOrDeleteUnaryExpression(currentNode, parentNode, currentKey);
};

},{"./supported-node-types":7,"estraverse":48}],10:[function(_dereq_,module,exports){
(function (process,__filename){
/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = _dereq_('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

}).call(this,_dereq_('_process'),"/node_modules/amdefine/amdefine.js")
},{"_process":12,"path":11}],11:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_('_process'))
},{"_process":12}],12:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
p