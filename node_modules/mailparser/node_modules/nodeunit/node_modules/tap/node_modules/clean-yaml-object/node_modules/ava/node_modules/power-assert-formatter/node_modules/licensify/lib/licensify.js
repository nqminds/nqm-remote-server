/**
 * licensify:
 *   Browserify plugin to prepend license header to your bundle
 *
 * https://github.com/twada/licensify
 *
 * Copyright (c) 2014-2016 Takuto Wada
 * Licensed under the MIT license.
 *   http://twada.mit-license.org/2014-2016
 */
'use strict';

var typeName = require('type-name');
var through = require('through2');
var convert = require('convert-source-map');
var offsetLines = require('offset-sourcemap-lines');
var nameToUrl = require('oss-license-name-to-url');
var props = [
    'license',
    'licenses',
    'author',
    'maintainers',
    'contributors',
    'homepage',
    'version'
];
var operators = [
    'OR',
    'AND'
];

function extractLicense (pkg, summary) {
    var name = '', operator = '', names = [], licenses = [];
    switch (typeName(pkg.license)) {
    case 'string':
        name = pkg.license;
        break;
    case 'Object':
        name = pkg.license.type;
        break;
    }

    if (name.match(/^\(.+\)$/)) {
        names = name.match(/\(([^)]+)\)/)[1];
        operators.forEach(function (o) {
            var license = names.split(o);
            if (licenses.length < license.length) {
                operator = o;
                licenses = license;
            }
        });
        summary.license = licenses.map(function (license) {
            return appendUrlToLicense(license.trim());
        }).filter(function (v) { return !!v; }).join(' ' + operator + ' ');
    } else if (name) {
        summary.license = appendUrlToLicense(name);
    }
}

function extractLicenses (pkg, summary) {
    if (typeName(pkg.licenses) === 'Array') {
        summary.licenses = pkg.licenses.map(function (license) {
            return appendUrlToLicense(license.type);
        }).filter(function (v) { return !!v; }).join(', ');
    }
}

function appendUrlToLicense (name) {
    if (!name) {
        return name;
    }
    var url = nameToUrl(name);
    if (url) {
        return name + ' (' + url + ')';
    } else {
        return name;
    }
}

function displayName (person) {
    switch (typeName(person)) {
    case 'string':
        return person;
    case 'Object':
        if (person.email) {
            return person.name + ' <' + person.email + '>';
        }
        return person.name;
    }
    return 'NO AUTHOR!';
}

function extractAuthor (pkg, summary) {
    if (pkg.author) {
        summary.author = displayName(pkg.author);
    }
}

function extractMaintainers (pkg, summary) {
    if (typeName(pkg.maintainers) === 'Array') {
        summary.maintainers = pkg.maintainers.map(function (person) {
            return displayName(person);
        }).join(', ');
    }
}

function extractContributors (pkg, summary) {
    if (typeName(pkg.contributors) === 'Array') {
        summary.contributors = pkg.contributors.map(function (person) {
            return displayName(person);
        }).join(', ');
    }
}

function extractHomepage (pkg, summary) {
    if (pkg.homepage) {
        summary.homepage = pkg.homepage;
    }
}

function extractVersion (pkg, summary) {
    if (pkg.version) {
        summary.version = pkg.version;
    }
}

function extractPrivate (pkg, summary) {
    if (pkg.private) {
        summary.private = pkg.private;
    }
}

function extract (pkg) {
    var summary = {};
    summary.name = pkg.name;
    extractLicense(pkg, summary);
    extractLicenses(pkg, summary);
    extractAuthor(pkg, summary);
    extractMaintainers(pkg, summary);
    extractContributors(pkg, summary);
    extractHomepage(pkg, summary);
    extractVersion(pkg, summary);
    extractPrivate(pkg, summary);
    return summary;
}

function createEachHeader(pkg, pluginOptions) {
    if (!pluginOptions.includePrivate && pkg.private) {
        return '';
    }
    var header = '';
    header += ' * ' + pkg.name + ':\n';
    props.forEach(function (prop) {
        if (pkg[prop]) {
            header += ' *   ' + prop + ': ' + pkg[prop] + '\n';
        }
    });
    header += ' *\n';
    return header;
}

function createLicenseHeader (mainPkg, licenses, pluginOptions) {
    var header = '';
    header += '/**\n';
    header += ' * Modules in this bundle\n';
    header += ' * @license\n';
    header += ' *\n';
    header += createEachHeader(mainPkg, pluginOptions);
    var keys = Object.keys(licenses);
    keys.sort();
    keys.forEach(function (key) {
        header += createEachHeader(licenses[key], pluginOptions);
    });
    header += ' * This header is generated by licensify (https://github.com/twada/licensify)\n';
    header += ' */\n';
    return header;
}

function newlinesIn (src) {
    if (!src) return 0;
    var newlines = src.match(/\n/g);
    return newlines ? newlines.length : 0;
}

module.exports = function licensify (b, opts) {
    var licenses = {};
    var scannedPkg = [];
    var mainPkg;

    function alreadyScanned (pkg) {
        return scannedPkg.some(function (scanned) {
            return pkg.name === scanned;
        });
    }

    b.on('package', function (pkg) {
        if (alreadyScanned(pkg)) {
            return;
        }

        if (!mainPkg) {
            mainPkg = extract(pkg);
        } else {
            licenses[pkg.name] = extract(pkg);
        }
        scannedPkg.push(pkg.name);

        // If this pkg has "browser" field, licensify scans the field and extracts informations.
        // see https://github.com/substack/browserify-handbook#browser-field
        if (pkg.browser && typeName(pkg.browser) === 'Object') {
            Object.keys(pkg.browser).forEach(function (key) {
                var subPkgPath = pkg.__dirname + '/node_modules/' + key + '/package.json';
                try {
                    var subPkg = require(subPkgPath);
                } catch (e) {
                    return;
                }
                licenses[subPkg.name] = extract(subPkg);
                scannedPkg.push(subPkg.name);
            });
        }
    });

    b.on('bundle', function () {
        var first = true;
        var header;
        b.pipeline.get('wrap').push(through.obj(function (buf, enc, next) {
            if (first) {
                header = createLicenseHeader(mainPkg, licenses, opts);
                this.push(new Buffer(header));
                first = false;
            }
            this.push(buf);
            next();
        }));
        if (b._options.debug) {
            b.pipeline.get('wrap').push(through.obj(function (buf, enc, next) {
                var conv = convert.fromSource(buf.toString('utf8'));
                if (conv) {
                    var offsetMap = offsetLines(conv.toObject(), newlinesIn(header));
                    this.push(new Buffer('\n' + convert.fromObject(offsetMap).toComment() + '\n'));
                } else {
                    this.push(buf);
                }
                next();
            }));
        }
    });
};
