(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('acorn'), require('magic-string')) :
	typeof define === 'function' && define.amd ? define(['exports', 'acorn', 'magic-string'], factory) :
	(factory((global.buble = global.buble || {}),global.acorn,global.MagicString));
}(this, function (exports,acorn,MagicString) { 'use strict';

	MagicString = 'default' in MagicString ? MagicString['default'] : MagicString;

	var statementsWithBlocks = {
		IfStatement: 'consequent',
		ForStatement: 'body',
		ForInStatement: 'body',
		ForOfStatement: 'body',
		WhileStatement: 'body',
		ArrowFunctionExpression: 'body'
	};

	var Node = function Node ( raw, parent ) {
		Object.defineProperties( this, {
			parent: { value: parent },
			program: { value: parent.program || parent },
			depth: { value: parent.depth + 1 },
			keys: { value: Object.keys( raw ) }
		});

		// special case – body-less if/for/while statements. TODO others?
		var type = statementsWithBlocks[ raw.type ];
		if ( type && raw[ type ].type !== 'BlockStatement' ) {
			var nonBlock = raw[ type ];

			// create a synthetic block statement, otherwise all hell
			// breaks loose when it comes to block scoping
			raw[ type ] = {
				start: nonBlock.start,
				end: nonBlock.end,
				type: 'BlockStatement',
				body: [ nonBlock ],
				synthetic: true
			};
		}

		for ( var i = 0, list = this.keys; i < list.length; i += 1 ) {
			var key = list[i];

				this[ key ] = wrap( raw[ key ], this );
		}

		this.program.magicString.addSourcemapLocation( this.start );
		this.program.magicString.addSourcemapLocation( this.end );
	};

	Node.prototype.ancestor = function ancestor ( level ) {
		var node = this;
		while ( level-- ) {
			node = node.parent;
			if ( !node ) return null;
		}

		return node;
	};

	Node.prototype.contains = function contains ( node ) {
		var this$1 = this;

			while ( node ) {
			if ( node === this$1 ) return true;
			node = node.parent;
		}

		return false;
	};

	Node.prototype.findLexicalBoundary = function findLexicalBoundary () {
		return this.parent.findLexicalBoundary();
	};

	Node.prototype.findNearest = function findNearest ( type ) {
		if ( typeof type === 'string' ) type = new RegExp( ("^" + type + "$") );
		if ( type.test( this.type ) ) return this;
		return this.parent.findNearest( type );
	};

	Node.prototype.findScope = function findScope ( functionScope ) {
		return this.parent.findScope( functionScope );
	};

	Node.prototype.getIndentation = function getIndentation () {
		var lastLine = /\n(.+)$/.exec( this.program.magicString.original.slice( 0, this.start ) );
		return lastLine ? /^[ \t]*/.exec( lastLine[1] )[0] : '';
	};

	Node.prototype.initialise = function initialise ( transforms ) {
		for ( var i = 0, list = this.keys; i < list.length; i += 1 ) {
			var key = list[i];

				var value = this[ key ];

			if ( Array.isArray( value ) ) {
				value.forEach( function ( node ) { return node && node.initialise( transforms ); } );
			} else if ( value && typeof value === 'object' ) {
				value.initialise( transforms );
			}
		}
	};

	Node.prototype.toString = function toString () {
		return this.program.magicString.slice( this.start, this.end );
	};

	Node.prototype.transpile = function transpile ( code, transforms ) {
		for ( var i = 0, list = this.keys; i < list.length; i += 1 ) {
			var key = list[i];

				var value = this[ key ];

			if ( Array.isArray( value ) ) {
				value.forEach( function ( node ) { return node && node.transpile( code, transforms ); } );
			} else if ( value && typeof value === 'object' ) {
				value.transpile( code, transforms );
			}
		}
	};

	var ArrayExpression = (function (Node) {
		function ArrayExpression () {
			Node.apply(this, arguments);
		}

		ArrayExpression.prototype = Object.create( Node && Node.prototype );
		ArrayExpression.prototype.constructor = ArrayExpression;

		ArrayExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.spreadRest ) {
				var lastElement = this.elements[ this.elements.length - 1 ];
				if ( lastElement && lastElement.type === 'SpreadElement' ) {
					var penultimateElement = this.elements[ this.elements.length - 2 ];

					if ( penultimateElement ) {
						code.overwrite( penultimateElement.end, lastElement.start, (" ].concat( ") );
					} else {
						code.insert( this.start + 1, ("].concat(") );
					}

					code.remove( lastElement.start, lastElement.start + 3 );

					var charIndex = lastElement.end;
					while ( code.original[ charIndex ] !== ']' ) charIndex += 1;

					code.overwrite( charIndex, charIndex + 1, ')' );
				}
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return ArrayExpression;
	}(Node));

	function findIndex ( array, fn ) {
		for ( var i = 0; i < array.length; i += 1 ) {
			if ( fn( array[i], i ) ) return i;
		}

		return -1;
	}

	function find ( array, fn ) {
		return array[ findIndex( array, fn ) ];
	}

	var ArrowFunctionExpression = (function (Node) {
		function ArrowFunctionExpression () {
			Node.apply(this, arguments);
		}

		ArrowFunctionExpression.prototype = Object.create( Node && Node.prototype );
		ArrowFunctionExpression.prototype.constructor = ArrowFunctionExpression;

		ArrowFunctionExpression.prototype.initialise = function initialise ( transforms ) {
			this.body.createScope();
			Node.prototype.initialise.call( this, transforms );
		};

		ArrowFunctionExpression.prototype.transpile = function transpile ( code, transforms ) {
			var this$1 = this;

			if ( transforms.arrow ) {
				if ( this.params.length === 0 ) {
					code.overwrite( this.start, this.body.start, 'function () ' );
				} else {
					code.insert( this.start, 'function ' );

					var parenthesised = false;
					var charIndex = this.start;
					while ( charIndex < this$1.params[0].start ) {
						if ( code.original[ charIndex ] === '(' ) {
							parenthesised = true;
							break;
						}
					}

					if ( !parenthesised ) {
						code.insert( this.start, '( ' );
					}

					charIndex = this.params[ this.params.length -1 ].end;
					while ( code.original[ charIndex ] !== '=' ) charIndex += 1;

					// remove the `=> `
					code.overwrite( charIndex, this.body.start, parenthesised ? '' : ') ' );
				}
			}

			if ( this.body.synthetic ) {
				if ( find( this.params, function ( param ) { return param.type === 'RestElement' || /Pattern/.test( param.type ); } ) ) {
					var indentation = this.getIndentation();
					code.insert( this.body.start, ("{\n" + indentation + "" + (code.getIndentString())) );
					Node.prototype.transpile.call( this, code, transforms );
					code.insert( this.body.end, (";\n" + indentation + "}") );
				}

				else if ( transforms.arrow ) {
					code.insert( this.body.start, ("{ ") );
					Node.prototype.transpile.call( this, code, transforms );
					code.insert( this.body.end, ("; }") );
				}
			}

			else {
				Node.prototype.transpile.call( this, code, transforms );
			}
		};

		return ArrowFunctionExpression;
	}(Node));

	function locate ( source, index ) {
		var lines = source.split( '\n' );
		var len = lines.length;

		var lineStart = 0;
		var i;

		for ( i = 0; i < len; i += 1 ) {
			var line = lines[i];
			var lineEnd =  lineStart + line.length + 1; // +1 for newline

			if ( lineEnd > index ) {
				return { line: i + 1, column: index - lineStart, char: i };
			}

			lineStart = lineEnd;
		}

		throw new Error( 'Could not determine location of character' );
	}

	function pad ( num, len ) {
		var result = String( num );
		return result + repeat( ' ', len - result.length );
	}

	function repeat ( str, times ) {
		var result = '';
		while ( times-- ) result += str;
		return result;
	}

	function getSnippet ( source, loc, length ) {
		if ( length === void 0 ) length = 1;

		var first = Math.max( loc.line - 5, 0 );
		var last = loc.line;

		var numDigits = String( last ).length;

		var lines = source.split( '\n' ).slice( first, last );

		var lastLine = lines[ lines.length - 1 ];
		var offset = lastLine.slice( 0, loc.column ).replace( /\t/g, '  ' ).length;

		var snippet = lines
			.map( function ( line, i ) { return ("" + (pad( i + first + 1, numDigits )) + " : " + (line.replace( /\t/g, '  '))); } )
			.join( '\n' );

		snippet += '\n' + repeat( ' ', numDigits + 3 + offset ) + repeat( '^', length );

		return snippet;
	}

	var CompileError = (function (Error) {
		function CompileError ( node, message ) {
			Error.call(this);

			var source = node.program.magicString.original;
			var loc = locate( source, node.start );

			this.name = 'CompileError';
			this.message = message + " (" + (loc.line) + ":" + (loc.column) + ")";

			this.stack = new Error().stack.replace( new RegExp( (".+new " + (this.name) + ".+\\n"), 'm' ), '' );

			this.loc = loc;
			this.snippet = getSnippet( source, loc, node.end - node.start );
		}

		CompileError.prototype = Object.create( Error && Error.prototype );
		CompileError.prototype.constructor = CompileError;

		return CompileError;
	}(Error));

	var AssignmentExpression = (function (Node) {
		function AssignmentExpression () {
			Node.apply(this, arguments);
		}

		AssignmentExpression.prototype = Object.create( Node && Node.prototype );
		AssignmentExpression.prototype.constructor = AssignmentExpression;

		AssignmentExpression.prototype.initialise = function initialise ( transforms ) {
			if ( this.left.type === 'Identifier' ) {
				var declaration = this.findScope( false ).findDeclaration( this.left.name );
				if ( declaration && declaration.kind === 'const' ) {
					throw new CompileError( this.left, ("" + (this.left.name) + " is read-only") );
				}

				// special case – https://gitlab.com/Rich-Harris/buble/issues/11
				var statement = declaration && declaration.node.ancestor( 3 );
				if ( statement && statement.type === 'ForStatement' && statement.body.contains( this ) ) {
					statement.reassigned[ this.left.name ] = true;
				}
			}

			if ( /Pattern/.test( this.left.type ) ) {
				throw new CompileError( this.left, 'Destructuring assignments are not currently supported. Coming soon!' );
			}

			Node.prototype.initialise.call( this, transforms );
		};

		AssignmentExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.operator === '**=' && transforms.exponentiation ) {
				var scope = this.findScope( false );
				var getAlias = function ( name ) {
					var declaration = scope.findDeclaration( name );
					return declaration ? declaration.name : name;
				};

				// first, the easy part – `**=` -> `=`
				var charIndex = this.left.end;
				while ( code.original[ charIndex ] !== '*' ) charIndex += 1;
				code.remove( charIndex, charIndex + 2 );

				// how we do the next part depends on a number of factors – whether
				// this is a top-level statement, and whether we're updating a
				// simple or complex reference
				var base;

				var left = this.left;
				while ( left.type === 'ParenthesizedExpression' ) left = left.expression;

				if ( left.type === 'Identifier' ) {
					base = getAlias( left.name );
				} else if ( left.type === 'MemberExpression' ) {
					var object;
					var needsObjectVar = false;
					var property;
					var needsPropertyVar = false;

					var statement = this.findNearest( /(?:Statement|Declaration)$/ );
					var i0 = statement.getIndentation();

					if ( left.property.type === 'Identifier' ) {
						property = left.computed ? getAlias( left.property.name ) : left.property.name;
					} else {
						property = scope.createIdentifier( 'property' );
						needsPropertyVar = true;
					}

					if ( left.object.type === 'Identifier' ) {
						object = getAlias( left.object.name );
					} else {
						object = scope.createIdentifier( 'object' );
						needsObjectVar = true;
					}

					if ( left.start === statement.start ) {
						if ( needsObjectVar && needsPropertyVar ) {
							code.insert( statement.start, ("var " + object + " = ") );
							code.overwrite( left.object.end, left.property.start, (";\n" + i0 + "var " + property + " = ") );
							code.overwrite( left.property.end, left.end, (";\n" + i0 + "" + object + "[" + property + "]") );
						}

						else if ( needsObjectVar ) {
							code.insert( statement.start, ("var " + object + " = ") );
							code.insert( left.object.end, (";\n" + i0) );
							code.insert( left.object.end, object );
						}

						else if ( needsPropertyVar ) {
							code.insert( statement.start, ("var " + property + " = ") );
							code.move( left.property.start, left.property.end, statement.start );
							code.insert( statement.start, (";\n" + i0) );

							code.overwrite( left.object.end, left.property.start, ("[" + property + "]") );
							code.remove( left.property.end, left.end );
						}
					}

					else {
						var declarators = [];
						if ( needsObjectVar ) declarators.push( object );
						if ( needsPropertyVar ) declarators.push( property );
						code.insert( statement.start, ("var " + (declarators.join( ', ' )) + ";\n" + i0) );

						code.insert( left.start, ("( ") );

						if ( needsObjectVar && needsPropertyVar ) {
							code.insert( left.start, ("" + object + " = ") );
							code.overwrite( left.object.end, left.property.start, (", " + property + " = ") );
							code.overwrite( left.property.end, left.end, (", " + object + "[" + property + "]") );
						}

						else if ( needsObjectVar ) {
							code.insert( left.start, ("" + object + " = ") );
							code.insert( left.object.end, (", " + object) );
						}

						else if ( needsPropertyVar ) {
							code.insert( left.start, ("" + property + " = ") );
							code.move( left.property.start, left.property.end, left.start );
							code.insert( left.start, (", ") );
							code.overwrite( left.object.end, left.property.start, ("[" + property + "]") );
							code.remove( left.property.end, left.end );
						}

						code.insert( this.end, (" )") );
					}

					base = object + ( left.computed || needsPropertyVar ? ("[" + property + "]") : ("." + property) );
				}

				code.insert( this.right.start, ("Math.pow( " + base + ", ") );
				code.insert( this.right.end, (" )") );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return AssignmentExpression;
	}(Node));

	var BinaryExpression = (function (Node) {
		function BinaryExpression () {
			Node.apply(this, arguments);
		}

		BinaryExpression.prototype = Object.create( Node && Node.prototype );
		BinaryExpression.prototype.constructor = BinaryExpression;

		BinaryExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.operator === '**' && transforms.exponentiation ) {
				code.insert ( this.start, ("Math.pow( ") );
				code.overwrite( this.left.end, this.right.start, (", ") );
				code.insert ( this.end, (" )") );
			}
			Node.prototype.transpile.call( this, code, transforms );
		};

		return BinaryExpression;
	}(Node));

	var BreakStatement = (function (Node) {
		function BreakStatement () {
			Node.apply(this, arguments);
		}

		BreakStatement.prototype = Object.create( Node && Node.prototype );
		BreakStatement.prototype.constructor = BreakStatement;

		BreakStatement.prototype.initialise = function initialise ( transforms ) {
			var loop = this.findNearest( /(?:For(?:In)?|While)Statement/ );
			var switchCase = this.findNearest( 'SwitchCase' );

			if ( loop && ( !switchCase || loop.depth > switchCase.depth ) ) {
				loop.canBreak = true;
				this.loop = loop;
			}
		};

		BreakStatement.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.loop && this.loop.shouldRewriteAsFunction ) {
				if ( this.label ) throw new CompileError( this, 'Labels are not currently supported in a loop with locally-scoped variables' );
				code.overwrite( this.start, this.start + 5, ("return 'break'") );
			}
		};

		return BreakStatement;
	}(Node));

	var CallExpression = (function (Node) {
		function CallExpression () {
			Node.apply(this, arguments);
		}

		CallExpression.prototype = Object.create( Node && Node.prototype );
		CallExpression.prototype.constructor = CallExpression;

		CallExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.spreadRest ) {
				var lastArgument = this.arguments[ this.arguments.length - 1 ];
				if ( lastArgument && lastArgument.type === 'SpreadElement' ) {
					// TODO expression callee (`(a || b)(...values)`)

					var context;

					if ( this.callee.type === 'MemberExpression' ) {
						if ( this.callee.object.type === 'Identifier' ) {
							context = this.callee.object.name;
						} else {
							throw new CompileError( lastArgument, 'Calling members of expressions with a spread operator is not currently supported' );
						}
					} else {
						context = 'void 0';
					}

					code.insert( this.callee.end, '.apply' );

					var penultimateArgument = this.arguments[ this.arguments.length - 2 ];

					if ( penultimateArgument ) {
						code.insert( this.arguments[0].start, ("" + context + ", [ ") );
						code.overwrite( penultimateArgument.end, lastArgument.start, (" ].concat( ") );
						code.insert( lastArgument.end, (" )") );
					} else {
						code.insert( lastArgument.start, ("" + context + ", ") );
					}

					code.remove( lastArgument.start, lastArgument.start + 3 );
				}
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return CallExpression;
	}(Node));

	// TODO this code is pretty wild, tidy it up
	var ClassBody = (function (Node) {
		function ClassBody () {
			Node.apply(this, arguments);
		}

		ClassBody.prototype = Object.create( Node && Node.prototype );
		ClassBody.prototype.constructor = ClassBody;

		ClassBody.prototype.transpile = function transpile ( code, transforms, inFunctionExpression, superName ) {
			if ( transforms.classes ) {
				var name = this.parent.name;

				var indentStr = code.getIndentString();
				var indentation = this.getIndentation() + ( inFunctionExpression ? indentStr : '' );

				var constructorIndex = findIndex( this.body, function ( node ) { return node.kind === 'constructor'; } );
				var constructor = this.body[ constructorIndex ];

				if ( this.body.length ) {
					code.remove( this.start, this.body[0].start );
					code.remove( this.body[ this.body.length - 1 ].end, this.end );
				} else {
					code.remove( this.start, this.end );
				}

				if ( constructor ) {
					var previousMethod = this.body[ constructorIndex - 1 ];
					var nextMethod = this.body[ constructorIndex + 1 ];

					// ensure constructor is first
					if ( constructorIndex > 0 ) {
						code.remove( previousMethod.end, constructor.start );
						code.move( constructor.start, nextMethod ? nextMethod.start : this.end - 1, this.body[0].start );
					}

					if ( !inFunctionExpression ) code.insert( constructor.end, ';' );

					if ( constructorIndex > 0 ) {
						if ( nextMethod ) {
							code.insert( nextMethod.start, ("\n\n" + indentation) );
						} else {
							code.insert( constructor.end, ("\n\n" + indentation) );
						}
					}
				} else {
					var fn = "function " + name + " () {" + ( superName ?
						("\n" + indentation + "" + indentStr + "" + superName + ".apply(this, arguments);\n" + indentation + "}") :
						("}") ) + ( inFunctionExpression ? '' : ';' ) + ( this.body.length ? ("\n\n" + indentation) : '' );
					code.insert( this.start, fn );
				}

				if ( this.parent.superClass ) {
					var inheritanceBlock = "" + name + ".prototype = Object.create( " + superName + " && " + superName + ".prototype );\n" + indentation + "" + name + ".prototype.constructor = " + name + ";";

					if ( constructor ) {
						code.insert( constructor.end, "\n\n" + indentation + inheritanceBlock );
					} else {
						code.insert( this.start, inheritanceBlock + "\n\n" + indentation );
					}
				}

				var scope = this.findScope( false );

				var gettersAndSetters = [];
				var accessors;

				this.body.forEach( function ( method ) {
					if ( method.kind === 'constructor' ) {
						code.overwrite( method.key.start, method.key.end, ("function " + name) );
						return;
					}

					var isAccessor = method.kind === 'get' || method.kind === 'set';

					if ( isAccessor ) {
						code.remove( method.start, method.key.end );

						if ( !~gettersAndSetters.indexOf( method.key.name ) ) gettersAndSetters.push( method.key.name );
						if ( !accessors ) accessors = scope.createIdentifier( 'accessors' );
					}

					if ( method.static ) code.remove( method.start, method.start + 7 );

					var lhs = method.static ?
						("" + name + "." + (method.key.name)) :
						method.kind === 'method' ?
							("" + name + ".prototype." + (method.key.name)) :
							("" + accessors + "." + (method.key.name) + "." + (method.kind));

					code.insert( method.start, "" + lhs + " = function" + ( method.value.generator ? '*' : '' ) + ( isAccessor ? '' : ' ' ) );
					code.insert( method.end, ';' );

					if ( method.value.generator ) code.remove( method.start, method.key.start );

					// prevent function name shadowing an existing declaration
					if ( scope.contains( method.key.name ) ) {
						code.overwrite( method.key.start, method.key.end, scope.createIdentifier( method.key.name ), true );
					}
				});

				if ( gettersAndSetters.length ) {
					var intro = "var " + accessors + " = { " + (gettersAndSetters.map( function ( name ) { return ("" + name + ": {}"); } ).join( ',' )) + " };";

					var outro = "Object.defineProperties( " + name + ".prototype, " + accessors + " );";

					if ( constructor ) {
						code.insert( constructor.end, ("\n\n" + indentation + "" + intro) );
					} else {
						code.insert( this.start, ("" + intro + "\n\n" + indentation) );
					}

					code.insert( this.end, ("\n\n" + indentation + "" + outro) );
				}
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return ClassBody;
	}(Node));

	// TODO this function is slightly flawed – it works on the original string,
	// not its current edited state.
	// That's not a problem for the way that it's currently used, but it could
	// be in future...
	function deindent ( node, code ) {
		var start = node.start;
		var end = node.end;

		var indentStr = code.getIndentString();
		var pattern = new RegExp( indentStr + '\\S', 'g' );

		if ( code.original.slice( start - indentStr.length, start ) === indentStr ) {
			code.remove( start - indentStr.length, start );
		}

		var slice = code.original.slice( start, end );
		var match;
		while ( match = pattern.exec( slice ) ) {
			if ( !node.program.indentExclusions[ match.index ] ) code.remove( start + match.index, start + match.index + indentStr.length );
		}
	}

	var ClassDeclaration = (function (Node) {
		function ClassDeclaration () {
			Node.apply(this, arguments);
		}

		ClassDeclaration.prototype = Object.create( Node && Node.prototype );
		ClassDeclaration.prototype.constructor = ClassDeclaration;

		ClassDeclaration.prototype.initialise = function initialise ( transforms ) {
			this.name = this.id.name;
			this.findScope( true ).addDeclaration( this.id, 'class' );

			Node.prototype.initialise.call( this, transforms );
		};

		ClassDeclaration.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.classes ) {
				if ( !this.superClass ) deindent( this.body, code );

				var superName = this.superClass && ( this.superClass.name || 'superclass' );

				var indentation = this.getIndentation();
				var indentStr = code.getIndentString();

				code.overwrite( this.start, this.id.start, 'var ' );

				if ( this.superClass ) {
					code.overwrite( this.id.end, this.superClass.start, ' = ' );
					code.overwrite( this.superClass.end, this.body.start, ("(function (" + superName + ") {\n" + indentation + "" + indentStr) );
				} else {
					code.overwrite( this.id.end, this.body.start, ' = ' );
				}

				this.body.transpile( code, transforms, !!this.superClass, superName );

				if ( this.superClass ) {
					code.insert( this.end, ("\n\n" + indentation + "" + indentStr + "return " + (this.name) + ";\n" + indentation + "}(") );
					code.move( this.superClass.start, this.superClass.end, this.end );
					code.insert( this.end, '));' );
				}
			}

			else {
				this.body.transpile( code, transforms, false, null );
			}
		};

		return ClassDeclaration;
	}(Node));

	var ClassExpression = (function (Node) {
		function ClassExpression () {
			Node.apply(this, arguments);
		}

		ClassExpression.prototype = Object.create( Node && Node.prototype );
		ClassExpression.prototype.constructor = ClassExpression;

		ClassExpression.prototype.initialise = function initialise ( transforms ) {
			this.name = this.id ? this.id.name :
			            this.parent.type === 'VariableDeclarator' ? this.parent.id.name :
			            this.parent.type === 'AssignmentExpression' ? this.parent.left.name :
			            this.findScope( true ).createIdentifier( 'anonymous' );
		};

		ClassExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.classes ) {
				var superName = this.superClass && ( this.superClass.name || 'superclass' );

				var i0 = this.getIndentation();
				var i1 = i0 + code.getIndentString();

				if ( this.superClass ) {
					code.remove( this.start, this.superClass.start );
					code.remove( this.superClass.end, this.body.start );
					code.insert( this.start, ("(function (" + superName + ") {\n" + i1) );
				} else {
					code.overwrite( this.start, this.body.start, ("(function () {\n" + i1) );
				}

				this.body.transpile( code, transforms, true, superName );

				var outro = "\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}(";

				if ( this.superClass ) {
					code.insert( this.end, outro );
					code.move( this.superClass.start, this.superClass.end, this.end );
					code.insert( this.end, '))' );
				} else {
					code.insert( this.end, ("\n\n" + i1 + "return " + (this.name) + ";\n" + i0 + "}())") );
				}
			}

			else {
				this.body.transpile( code, transforms, false );
			}
		};

		return ClassExpression;
	}(Node));

	var ContinueStatement = (function (Node) {
		function ContinueStatement () {
			Node.apply(this, arguments);
		}

		ContinueStatement.prototype = Object.create( Node && Node.prototype );
		ContinueStatement.prototype.constructor = ContinueStatement;

		ContinueStatement.prototype.transpile = function transpile ( code, transforms ) {
			var loop = this.findNearest( /(?:For(?:In)?|While)Statement/ );
			if ( loop.shouldRewriteAsFunction ) {
				if ( this.label ) throw new CompileError( this, 'Labels are not currently supported in a loop with locally-scoped variables' );
				code.overwrite( this.start, this.start + 8, 'return' );
			}
		};

		return ContinueStatement;
	}(Node));

	var ExportDefaultDeclaration = (function (Node) {
		function ExportDefaultDeclaration () {
			Node.apply(this, arguments);
		}

		ExportDefaultDeclaration.prototype = Object.create( Node && Node.prototype );
		ExportDefaultDeclaration.prototype.constructor = ExportDefaultDeclaration;

		ExportDefaultDeclaration.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.moduleExport ) throw new CompileError( this, 'export is not supported' );
			Node.prototype.initialise.call( this, transforms );
		};

		ExportDefaultDeclaration.prototype.transpile = function transpile ( code, transforms ) {
			Node.prototype.transpile.call( this, code, transforms );

			if ( this.declaration.type === 'ClassDeclaration' ) {
				code.insert( this.end, ("\n\n" + (this.getIndentation())) );
				code.move( this.start, this.declaration.start, this.end );
				code.insert( this.end, ("" + (this.declaration.id.name) + ";") );
			}
		};

		return ExportDefaultDeclaration;
	}(Node));

	var ExportNamedDeclaration = (function (Node) {
		function ExportNamedDeclaration () {
			Node.apply(this, arguments);
		}

		ExportNamedDeclaration.prototype = Object.create( Node && Node.prototype );
		ExportNamedDeclaration.prototype.constructor = ExportNamedDeclaration;

		ExportNamedDeclaration.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.moduleExport ) throw new CompileError( this, 'export is not supported' );
			Node.prototype.initialise.call( this, transforms );
		};

		return ExportNamedDeclaration;
	}(Node));

	function extractNames ( node ) {
		var names = [];
		extractors[ node.type ]( names, node );
		return names;
	}

	var extractors = {
		Identifier: function Identifier ( names, param ) {
			names.push( param.name );
		},

		ObjectPattern: function ObjectPattern ( names, param ) {
			for ( var i = 0, list = param.properties; i < list.length; i += 1 ) {
				var prop = list[i];

				extractors[ prop.value.type ]( names, prop.value );
			}
		},

		ArrayPattern: function ArrayPattern ( names, param ) {
			for ( var i = 0, list = param.elements; i < list.length; i += 1 )  {
				var element = list[i];

				if ( element ) extractors[ element.type ]( names, element );
			}
		},

		RestElement: function RestElement ( names, param ) {
			extractors[ param.argument.type ]( names, param.argument );
		},

		AssignmentPattern: function AssignmentPattern ( names, param ) {
			extractors[ param.left.type ]( names, param.left );
		}
	};

	var LoopStatement = (function (Node) {
		function LoopStatement () {
			Node.apply(this, arguments);
		}

		LoopStatement.prototype = Object.create( Node && Node.prototype );
		LoopStatement.prototype.constructor = LoopStatement;

		LoopStatement.prototype.findScope = function findScope ( functionScope ) {
			return functionScope || !this.createdScope ? this.parent.findScope( functionScope ) : this.body.scope;
		};

		LoopStatement.prototype.initialise = function initialise ( transforms ) {
			var this$1 = this;

			this.body.createScope();
			this.createdScope = true;

			// this is populated as and when reassignments occur
			this.reassigned = Object.create( null );
			this.aliases = Object.create( null );

			Node.prototype.initialise.call( this, transforms );

			if ( transforms.letConst ) {
				// see if any block-scoped declarations are referenced
				// inside function expressions
				var names = Object.keys( this.body.scope.declarations );

				var i = names.length;
				while ( i-- ) {
					var name = names[i];
					var declaration = this$1.body.scope.declarations[ name ];

					var j = declaration.instances.length;
					while ( j-- ) {
						var instance = declaration.instances[j];
						var nearestFunctionExpression = instance.findNearest( /Function/ );

						if ( nearestFunctionExpression && nearestFunctionExpression.depth > this$1.depth ) {
							this$1.shouldRewriteAsFunction = true;
							break;
						}
					}

					if ( this$1.shouldRewriteAsFunction ) break;
				}
			}
		};

		LoopStatement.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.shouldRewriteAsFunction ) {
				var i0 = this.getIndentation();
				var i1 = i0 + code.getIndentString();

				var argString = this.args ? (" " + (this.args.join( ', ' )) + " ") : '';
				var paramString = this.params ? (" " + (this.params.join( ', ' )) + " ") : '';

				var functionScope = this.findScope( true );
				var loop = functionScope.createIdentifier( 'loop' );

				var before = "var " + loop + " = function (" + paramString + ") " + ( this.body.synthetic ? ("{\n" + i0 + "" + (code.getIndentString())) : '' );
				var after = ( this.body.synthetic ? ("\n" + i0 + "}") : '' ) + ";\n\n" + i0;

				code.insert( this.start, before );
				code.move( this.body.start, this.body.end, this.start );
				code.insert( this.start, after );

				var index = this.type === 'DoWhileStatement' ?
					this.start + 2 :
					this.end;

				if ( this.canBreak || this.canReturn ) {
					var returned = functionScope.createIdentifier( 'returned' );

					var insert = "{\n" + i1 + "var " + returned + " = " + loop + "(" + argString + ");\n";
					if ( this.canBreak ) insert += "\n" + i1 + "if ( " + returned + " === 'break' ) break;";
					if ( this.canReturn ) insert += "\n" + i1 + "if ( " + returned + " ) return returned.v;";
					insert += "\n" + i0 + "}";

					code.insert( index, insert );
				} else {
					var callExpression = "" + loop + "(" + argString + ");";

					if ( this.type === 'DoWhileStatement' ) {
						code.overwrite( this.start, this.body.start, ("do {\n" + i1 + "" + callExpression + "\n" + i0 + "}") );
					} else {
						code.insert( index, callExpression );
					}
				}
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return LoopStatement;
	}(Node));

	var ForStatement = (function (LoopStatement) {
		function ForStatement () {
			LoopStatement.apply(this, arguments);
		}

		ForStatement.prototype = Object.create( LoopStatement && LoopStatement.prototype );
		ForStatement.prototype.constructor = ForStatement;

		ForStatement.prototype.findScope = function findScope ( functionScope ) {
			return functionScope || !this.createdScope ? this.parent.findScope( functionScope ) : this.body.scope;
		};

		ForStatement.prototype.transpile = function transpile ( code, transforms ) {
			var this$1 = this;

			var i1 = this.getIndentation() + code.getIndentString();

			if ( this.shouldRewriteAsFunction ) {
				// which variables are declared in the init statement?
				var names = this.init.type === 'VariableDeclaration' ?
					[].concat.apply( [], this.init.declarations.map( function ( declarator ) { return extractNames( declarator.id ); } ) ) :
					[];

				var aliases = this.aliases;

				this.args = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].outer : name; } );
				this.params = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].inner : name; } );

				var updates = Object.keys( this.reassigned )
					.map( function ( name ) { return ("" + (aliases[ name ].outer) + " = " + (aliases[ name ].inner) + ";"); } );

				if ( updates.length ) {
					if ( this.body.synthetic ) {
						code.insert( this.body.body[0].end, ("; " + (updates.join((" ")))) );
					} else {
						var lastStatement = this.body.body[ this.body.body.length - 1 ];
						code.insert( lastStatement.end, ("\n\n" + i1 + "" + (updates.join(("\n" + i1)))) );
					}
				}
			}

			LoopStatement.prototype.transpile.call( this, code, transforms );
		};

		return ForStatement;
	}(LoopStatement));

	var ForInStatement = (function (LoopStatement) {
		function ForInStatement () {
			LoopStatement.apply(this, arguments);
		}

		ForInStatement.prototype = Object.create( LoopStatement && LoopStatement.prototype );
		ForInStatement.prototype.constructor = ForInStatement;

		ForInStatement.prototype.findScope = function findScope ( functionScope ) {
			return functionScope || !this.createdScope ? this.parent.findScope( functionScope ) : this.body.scope;
		};

		ForInStatement.prototype.transpile = function transpile ( code, transforms ) {
			var this$1 = this;

			if ( this.shouldRewriteAsFunction ) {
				// which variables are declared in the init statement?
				var names = this.left.type === 'VariableDeclaration' ?
					[].concat.apply( [], this.left.declarations.map( function ( declarator ) { return extractNames( declarator.id ); } ) ) :
					[];

				this.args = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].outer : name; } );
				this.params = names.map( function ( name ) { return name in this$1.aliases ? this$1.aliases[ name ].inner : name; } );
			}

			LoopStatement.prototype.transpile.call( this, code, transforms );
		};

		return ForInStatement;
	}(LoopStatement));

	var ForOfStatement = (function (LoopStatement) {
		function ForOfStatement () {
			LoopStatement.apply(this, arguments);
		}

		ForOfStatement.prototype = Object.create( LoopStatement && LoopStatement.prototype );
		ForOfStatement.prototype.constructor = ForOfStatement;

		ForOfStatement.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.forOf && !transforms.dangerousForOf ) throw new CompileError( this, 'for...of statements are not supported. Use `transforms: { forOf: false }` to skip transformation and disable this error, or `transforms: { dangerousForOf: true }` if you know what you\'re doing' );
			LoopStatement.prototype.initialise.call( this, transforms );
		};

		ForOfStatement.prototype.transpile = function transpile ( code, transforms ) {
			if ( !transforms.dangerousForOf ) {
				LoopStatement.prototype.transpile.call( this, code, transforms );
				return;
			}

			var scope = this.findScope( true );
			var i0 = this.getIndentation();
			var i1 = i0 + code.getIndentString();

			var key = scope.createIdentifier( 'i' );
			var list = scope.createIdentifier( 'list' );

			if ( this.body.synthetic ) {
				code.insert( this.body.body[0].start, ("{\n" + i1) );
				code.insert( this.body.body[0].end, ("\n" + i0 + "}") );
			}

			// this is rather finicky, owing to magic-string's quirks
			var bodyStart = this.body.body[0].start;
			var startIndex = this.left.start;
			while ( code.original[ startIndex - 1 ] !== '(' ) startIndex -= 1;

			code.remove( this.left.end, this.right.start );
			code.remove( startIndex, this.left.start );
			code.remove( this.start + 3, startIndex );

			code.insert( startIndex, (" ( var " + key + " = 0, " + list + " = ") );

			code.move( this.left.start, this.left.end, bodyStart );
			code.move( this.right.start, this.right.end, startIndex );
			code.insert( startIndex, ("; " + key + " < " + list + ".length; " + key + " += 1") );
			code.insert( bodyStart, (" = " + list + "[" + key + "];\n\n" + i1) );

			LoopStatement.prototype.transpile.call( this, code, transforms );
		};

		return ForOfStatement;
	}(LoopStatement));

	var FunctionDeclaration = (function (Node) {
		function FunctionDeclaration () {
			Node.apply(this, arguments);
		}

		FunctionDeclaration.prototype = Object.create( Node && Node.prototype );
		FunctionDeclaration.prototype.constructor = FunctionDeclaration;

		FunctionDeclaration.prototype.initialise = function initialise ( transforms ) {
			if ( this.generator && transforms.generator ) {
				throw new CompileError( this, 'Generators are not supported' );
			}

			this.body.createScope();

			this.findScope( true ).addDeclaration( this.id, 'function' );
			Node.prototype.initialise.call( this, transforms );
		};

		return FunctionDeclaration;
	}(Node));

	var FunctionExpression = (function (Node) {
		function FunctionExpression () {
			Node.apply(this, arguments);
		}

		FunctionExpression.prototype = Object.create( Node && Node.prototype );
		FunctionExpression.prototype.constructor = FunctionExpression;

		FunctionExpression.prototype.initialise = function initialise ( transforms ) {
			if ( this.generator && transforms.generator ) {
				throw new CompileError( this, 'Generators are not supported' );
			}

			this.body.createScope();

			if ( this.id ) {
				// function expression IDs belong to the child scope...
				this.body.scope.addDeclaration( this.id, 'function' );
			}

			Node.prototype.initialise.call( this, transforms );
		};

		return FunctionExpression;
	}(Node));

	function isReference ( node, parent ) {
		if ( node.type === 'MemberExpression' ) {
			return !node.computed && isReference( node.object, node );
		}

		if ( node.type === 'Identifier' ) {
			// the only time we could have an identifier node without a parent is
			// if it's the entire body of a function without a block statement –
			// i.e. an arrow function expression like `a => a`
			if ( !parent ) return true;

			// TODO is this right?
			if ( parent.type === 'MemberExpression' || parent.type === 'MethodDefinition' ) {
				return parent.computed || node === parent.object;
			}

			// disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
			if ( parent.type === 'Property' ) return parent.computed || node === parent.value;

			// disregard the `bar` in `class Foo { bar () {...} }`
			if ( parent.type === 'MethodDefinition' ) return false;

			// disregard the `bar` in `export { foo as bar }`
			if ( parent.type === 'ExportSpecifier' && node !== parent.local ) return;

			return true;
		}
	}

	var Identifier = (function (Node) {
		function Identifier () {
			Node.apply(this, arguments);
		}

		Identifier.prototype = Object.create( Node && Node.prototype );
		Identifier.prototype.constructor = Identifier;

		Identifier.prototype.findScope = function findScope ( functionScope ) {
			if ( this.parent.params && ~this.parent.params.indexOf( this ) ) {
				return this.parent.body.scope;
			}

			if ( this.parent.type === 'FunctionExpression' && this === this.parent.id ) {
				return this.parent.body.scope;
			}

			return this.parent.findScope( functionScope	);
		};

		Identifier.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.arrow && isReference( this, this.parent ) ) {
				if ( this.name === 'arguments' && !this.findScope( false ).contains( this.name ) ) {
					var lexicalBoundary = this.findLexicalBoundary();
					var arrowFunction = this.findNearest( 'ArrowFunctionExpression' );
					var loop = this.findNearest( /(?:For|While)Statement/ );

					if ( arrowFunction && arrowFunction.depth > lexicalBoundary.depth ) {
						this.alias = lexicalBoundary.getArgumentsAlias();
					}

					if ( loop && loop.depth > lexicalBoundary.depth ) {
						this.alias = lexicalBoundary.getArgumentsAlias();
					}
				}

				this.findScope( false ).addReference( this );
			}
		};

		Identifier.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.alias ) {
				code.overwrite( this.start, this.end, this.alias, true );
			}
		};

		return Identifier;
	}(Node));

	var ImportDeclaration = (function (Node) {
		function ImportDeclaration () {
			Node.apply(this, arguments);
		}

		ImportDeclaration.prototype = Object.create( Node && Node.prototype );
		ImportDeclaration.prototype.constructor = ImportDeclaration;

		ImportDeclaration.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.moduleImport ) throw new CompileError( this, 'import is not supported' );
			Node.prototype.initialise.call( this, transforms );
		};

		return ImportDeclaration;
	}(Node));

	var ImportDefaultSpecifier = (function (Node) {
		function ImportDefaultSpecifier () {
			Node.apply(this, arguments);
		}

		ImportDefaultSpecifier.prototype = Object.create( Node && Node.prototype );
		ImportDefaultSpecifier.prototype.constructor = ImportDefaultSpecifier;

		ImportDefaultSpecifier.prototype.initialise = function initialise ( transforms ) {
			this.findScope( true ).addDeclaration( this.local, 'import' );
			Node.prototype.initialise.call( this, transforms );
		};

		return ImportDefaultSpecifier;
	}(Node));

	var ImportSpecifier = (function (Node) {
		function ImportSpecifier () {
			Node.apply(this, arguments);
		}

		ImportSpecifier.prototype = Object.create( Node && Node.prototype );
		ImportSpecifier.prototype.constructor = ImportSpecifier;

		ImportSpecifier.prototype.initialise = function initialise ( transforms ) {
			this.findScope( true ).addDeclaration( this.local, 'import' );
			Node.prototype.initialise.call( this, transforms );
		};

		return ImportSpecifier;
	}(Node));

	var Literal = (function (Node) {
		function Literal () {
			Node.apply(this, arguments);
		}

		Literal.prototype = Object.create( Node && Node.prototype );
		Literal.prototype.constructor = Literal;

		Literal.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.numericLiteral ) {
				var leading = this.raw.slice( 0, 2 );
				if ( leading === '0b' || leading === '0o' ) {
					code.overwrite( this.start, this.end, String( this.value ), true );
				}
			}

			if ( this.regex ) {
				if ( transforms.unicodeRegExp && /u/.test( this.regex.flags ) ) throw new CompileError( this, 'Regular expression unicode flag is not supported' );
				if ( transforms.stickyRegExp && /y/.test( this.regex.flags ) ) throw new CompileError( this, 'Regular expression sticky flag is not supported' );
			}
		};

		return Literal;
	}(Node));

	var reserved = Object.create( null );
	'do if in for let new try var case else enum eval null this true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof'.split( ' ' )
		.forEach( function ( word ) { return reserved[ word ] = true; } );

	var MemberExpression = (function (Node) {
		function MemberExpression () {
			Node.apply(this, arguments);
		}

		MemberExpression.prototype = Object.create( Node && Node.prototype );
		MemberExpression.prototype.constructor = MemberExpression;

		MemberExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.reservedProperties && reserved[ this.property.name ] ) {
				code.overwrite( this.object.end, this.property.start, ("['") );
				code.insert( this.property.end, ("']") );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return MemberExpression;
	}(Node));

	var Property = (function (Node) {
		function Property () {
			Node.apply(this, arguments);
		}

		Property.prototype = Object.create( Node && Node.prototype );
		Property.prototype.constructor = Property;

		Property.prototype.initialise = function initialise ( transforms ) {
			if ( this.computed && transforms.computedProperty ) {
				throw new CompileError( this.key, 'Computed properties are not supported' );
			}

			Node.prototype.initialise.call( this, transforms );
		};

		Property.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.conciseMethodProperty && this.parent.type !== 'ObjectPattern' ) {
				if ( this.shorthand ) {
					code.insert( this.start, ("" + (this.key.name) + ": ") );
				} else if ( this.method ) {
					var name = this.findScope( true ).createIdentifier( this.key.name );
					if ( this.value.generator ) code.remove( this.start, this.key.start );
					code.insert( this.key.end, (": function" + (this.value.generator ? '*' : '') + " " + name) );
				}
			}

			if ( transforms.reservedProperties && reserved[ this.key.name ] ) {
				code.insert( this.key.start, ("'") );
				code.insert( this.key.end, ("'") );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return Property;
	}(Node));

	var ReturnStatement = (function (Node) {
		function ReturnStatement () {
			Node.apply(this, arguments);
		}

		ReturnStatement.prototype = Object.create( Node && Node.prototype );
		ReturnStatement.prototype.constructor = ReturnStatement;

		ReturnStatement.prototype.initialise = function initialise ( transforms ) {
			this.loop = this.findNearest( /(?:For(?:In)?|While)Statement/ );
			this.nearestFunction = this.findNearest( /Function/ );

			if ( this.loop && ( !this.nearestFunction || this.loop.depth > this.nearestFunction.depth ) ) {
				this.loop.canReturn = true;
				this.shouldWrap = true;
			}

			if ( this.argument ) this.argument.initialise( transforms );
		};

		ReturnStatement.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.argument ) {
				var shouldWrap = this.shouldWrap && this.loop && this.loop.shouldRewriteAsFunction;
				if ( shouldWrap ) code.insert( this.argument.start, ("{ v: ") );

				if ( this.argument ) this.argument.transpile( code, transforms );

				if ( shouldWrap ) code.insert( this.argument.end, (" }") );
			}
		};

		return ReturnStatement;
	}(Node));

	var Super = (function (Node) {
		function Super () {
			Node.apply(this, arguments);
		}

		Super.prototype = Object.create( Node && Node.prototype );
		Super.prototype.constructor = Super;

		Super.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.classes ) {
				this.method = this.findNearest( 'MethodDefinition' );
				if ( !this.method ) throw new CompileError( this, 'use of super outside class method' );

				var parentClass = this.findNearest( 'ClassBody' ).parent;
				this.superClassName = parentClass.superClass && parentClass.superClass.name;

				if ( !this.superClassName ) throw new CompileError( this, 'super used in base class' );

				this.isCalled = this.parent.type === 'CallExpression' && this === this.parent.callee;

				if ( this.method.kind !== 'constructor' && this.isCalled ) {
					throw new CompileError( this, 'super() not allowed outside class constructor' );
				}

				this.isMember = this.parent.type === 'MemberExpression';

				if ( !this.isCalled && !this.isMember ) {
					throw new CompileError( this, 'Unexpected use of `super` (expected `super(...)` or `super.*`)' );
				}
			}
		};

		Super.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.classes ) {
				var expression = this.isCalled ? this.superClassName : ("" + (this.superClassName) + ".prototype");
				code.overwrite( this.start, this.end, expression, true );

				var callExpression = this.isCalled ? this.parent : this.parent.parent;

				if ( callExpression && callExpression.type === 'CallExpression' ) {
					code.insert( callExpression.callee.end, '.call' );

					if ( callExpression.arguments.length ) {
						code.insert( callExpression.arguments[0].start, ("this, ") );
					} else {
						code.insert( callExpression.end - 1, ("this") );
					}
				}
			}
		};

		return Super;
	}(Node));

	var TaggedTemplateExpression = (function (Node) {
		function TaggedTemplateExpression () {
			Node.apply(this, arguments);
		}

		TaggedTemplateExpression.prototype = Object.create( Node && Node.prototype );
		TaggedTemplateExpression.prototype.constructor = TaggedTemplateExpression;

		TaggedTemplateExpression.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.templateString && !transforms.dangerousTaggedTemplateString ) {
				throw new CompileError( this, 'Tagged template strings are not supported. Use `transforms: { templateString: false }` to skip transformation and disable this error, or `transforms: { dangerousTaggedTemplateString: true }` if you know what you\'re doing' );
			}

			Node.prototype.initialise.call( this, transforms );
		};

		TaggedTemplateExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.templateString && transforms.dangerousTaggedTemplateString ) {
				var ordered = this.quasi.expressions.concat( this.quasi.quasis ).sort( function ( a, b ) { return a.start - b.start; } );

				// insert strings at start
				var templateStrings = this.quasi.quasis.map( function ( quasi ) { return JSON.stringify( quasi.value.cooked ); } );
				code.overwrite( this.tag.end, ordered[0].start, ("([" + (templateStrings.join(', ')) + "]") );

				var lastIndex = ordered[0].start;
				ordered.forEach( function ( node ) {
					if ( node.type === 'TemplateElement' ) {
						code.remove( lastIndex, node.end );
					} else {
						code.overwrite( lastIndex, node.start, ', ' );
					}

					lastIndex = node.end;
				});

				code.overwrite( lastIndex, this.end, ')' );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return TaggedTemplateExpression;
	}(Node));

	var TemplateElement = (function (Node) {
		function TemplateElement () {
			Node.apply(this, arguments);
		}

		TemplateElement.prototype = Object.create( Node && Node.prototype );
		TemplateElement.prototype.constructor = TemplateElement;

		TemplateElement.prototype.initialise = function initialise ( transforms ) {
			this.program.templateElements.push( this );
		};

		return TemplateElement;
	}(Node));

	var TemplateLiteral = (function (Node) {
		function TemplateLiteral () {
			Node.apply(this, arguments);
		}

		TemplateLiteral.prototype = Object.create( Node && Node.prototype );
		TemplateLiteral.prototype.constructor = TemplateLiteral;

		TemplateLiteral.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.templateString && this.parent.type !== 'TaggedTemplateExpression' ) {
				code.remove( this.start, this.start + 1 );
				code.remove( this.end - 1, this.end );

				var ordered = this.expressions.concat( this.quasis ).sort( function ( a, b ) { return a.start - b.start; } );

				var parenthesise = this.parent.type !== 'AssignmentExpression' &&
				                     this.parent.type !== 'VariableDeclarator' &&
				                     ( this.parent.type !== 'BinaryExpression' || this.parent.operator !== '+' );

				if ( parenthesise ) code.insert( this.start, '(' );

				var lastIndex = this.start;
				var closeParenthesis = false;

				ordered.forEach( function ( node, i ) {
					if ( node.type === 'TemplateElement' ) {
						var stringified = JSON.stringify( node.value.cooked );
						var replacement = ( closeParenthesis ? ')' : '' ) + ( ( node.tail && !node.value.cooked.length && i !== 0 ) ? '' : ("" + (i ? ' + ' : '') + "" + stringified) );
						code.overwrite( lastIndex, node.end, replacement );

						closeParenthesis = false;
					} else {
						var parenthesise = node.type !== 'Identifier'; // TODO other cases where it's safe
						var open = parenthesise ? ( i ? ' + (' : '(' ) : ' + ';

						code.overwrite( lastIndex, node.start, open );

						closeParenthesis = parenthesise;
					}

					lastIndex = node.end;
				});

				code.overwrite( lastIndex, this.end, parenthesise ? ')' : '' );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return TemplateLiteral;
	}(Node));

	var ThisExpression = (function (Node) {
		function ThisExpression () {
			Node.apply(this, arguments);
		}

		ThisExpression.prototype = Object.create( Node && Node.prototype );
		ThisExpression.prototype.constructor = ThisExpression;

		ThisExpression.prototype.initialise = function initialise ( transforms ) {
			if ( transforms.arrow ) {
				var lexicalBoundary = this.findLexicalBoundary();
				var arrowFunction = this.findNearest( 'ArrowFunctionExpression' );
				var loop = this.findNearest( /(?:For|While)Statement/ );

				if ( arrowFunction && arrowFunction.depth > lexicalBoundary.depth ) {
					this.alias = lexicalBoundary.getThisAlias();
				}

				if ( loop && loop.depth > lexicalBoundary.depth ) {
					this.alias = lexicalBoundary.getThisAlias();
				}
			}
		};

		ThisExpression.prototype.transpile = function transpile ( code, transforms ) {
			if ( this.alias ) {
				code.overwrite( this.start, this.end, this.alias, true );
			}
		};

		return ThisExpression;
	}(Node));

	var UpdateExpression = (function (Node) {
		function UpdateExpression () {
			Node.apply(this, arguments);
		}

		UpdateExpression.prototype = Object.create( Node && Node.prototype );
		UpdateExpression.prototype.constructor = UpdateExpression;

		UpdateExpression.prototype.initialise = function initialise ( transforms ) {
			if ( this.argument.type === 'Identifier' ) {
				var declaration = this.findScope( false ).findDeclaration( this.argument.name );
				if ( declaration && declaration.kind === 'const' ) {
					throw new CompileError( this, ("" + (this.argument.name) + " is read-only") );
				}
			}

			Node.prototype.initialise.call( this, transforms );
		};

		return UpdateExpression;
	}(Node));

	var VariableDeclaration = (function (Node) {
		function VariableDeclaration () {
			Node.apply(this, arguments);
		}

		VariableDeclaration.prototype = Object.create( Node && Node.prototype );
		VariableDeclaration.prototype.constructor = VariableDeclaration;

		VariableDeclaration.prototype.initialise = function initialise ( transforms ) {
			this.scope = this.findScope( this.kind === 'var' );
			this.declarations.forEach( function ( declarator ) { return declarator.initialise( transforms ); } );
		};

		VariableDeclaration.prototype.transpile = function transpile ( code, transforms ) {
			if ( transforms.letConst && this.kind !== 'var' ) {
				code.overwrite( this.start, this.start + this.kind.length, 'var', true );
			}

			this.declarations.forEach( function ( declarator ) { return declarator.transpile( code, transforms ); } );
		};

		return VariableDeclaration;
	}(Node));

	var VariableDeclarator = (function (Node) {
		function VariableDeclarator () {
			Node.apply(this, arguments);
		}

		VariableDeclarator.prototype = Object.create( Node && Node.prototype );
		VariableDeclarator.prototype.constructor = VariableDeclarator;

		VariableDeclarator.prototype.initialise = function initialise ( transforms ) {
			var this$1 = this;

			this.isObjectPattern = this.id.type === 'ObjectPattern';

			// disallow compound destructuring, for now at least
			if ( /Pattern/.test( this.id.type ) ) {
				this.id[ this.isObjectPattern ? 'properties' : 'elements' ].forEach( function ( node ) {
					if ( node && /Pattern/.test( this$1.isObjectPattern ? node.value.type : node.type ) ) {
						throw new CompileError( node.value, 'Compound destructuring is not supported' );
					}
				});
			}

			var kind = this.parent.kind;
			if ( kind === 'let' && this.parent.parent.type === 'ForStatement' ) {
				kind = 'for.let'; // special case...
			}

			this.parent.scope.addDeclaration( this.id, kind );
			Node.prototype.initialise.call( this, transforms );
		};

		VariableDeclarator.prototype.transpile = function transpile ( code, transforms ) {
			var this$1 = this;

			if ( transforms.destructuring && this.id.type !== 'Identifier' ) {
				var simple = this.init.type === 'Identifier';
				var name = simple ? this.init.name : this.findScope( true ).createIdentifier( 'ref' );

				if ( !simple ) {
					code.insert( this.start, ("" + name + " = ") );
					code.move( this.init.start, this.init.end, this.start );
					code.insert( this.start, (", ") );
				} else {
					code.remove( this.init.start, this.init.end );
				}

				var props = this.isObjectPattern ? this.id.properties : this.id.elements;

				code.remove( this.start, props[0].start );

				var lastIndex = this.start;
				var first = true;

				props.forEach( function ( property, i ) {
					if ( property ) {
						var id = this$1.isObjectPattern ? property.value : property;
						var rhs = this$1.isObjectPattern ? ("" + name + "." + (property.key.name)) : ("" + name + "[" + i + "]");

						code.overwrite( lastIndex, id.start, ("" + (first ? '' : ', ')) );
						code.insert( id.end, (" = " + rhs) );

						lastIndex = property.end;
						first = false;
					}
				});

				code.remove( lastIndex, this.init.start );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return VariableDeclarator;
	}(Node));

	var types = {
		ArrayExpression: ArrayExpression,
		ArrowFunctionExpression: ArrowFunctionExpression,
		AssignmentExpression: AssignmentExpression,
		BinaryExpression: BinaryExpression,
		BreakStatement: BreakStatement,
		CallExpression: CallExpression,
		ClassBody: ClassBody,
		ClassDeclaration: ClassDeclaration,
		ClassExpression: ClassExpression,
		ContinueStatement: ContinueStatement,
		DoWhileStatement: LoopStatement,
		ExportNamedDeclaration: ExportNamedDeclaration,
		ExportDefaultDeclaration: ExportDefaultDeclaration,
		ForStatement: ForStatement,
		ForInStatement: ForInStatement,
		ForOfStatement: ForOfStatement,
		FunctionDeclaration: FunctionDeclaration,
		FunctionExpression: FunctionExpression,
		Identifier: Identifier,
		ImportDeclaration: ImportDeclaration,
		ImportDefaultSpecifier: ImportDefaultSpecifier,
		ImportSpecifier: ImportSpecifier,
		Literal: Literal,
		MemberExpression: MemberExpression,
		Property: Property,
		ReturnStatement: ReturnStatement,
		Super: Super,
		TaggedTemplateExpression: TaggedTemplateExpression,
		TemplateElement: TemplateElement,
		TemplateLiteral: TemplateLiteral,
		ThisExpression: ThisExpression,
		UpdateExpression: UpdateExpression,
		VariableDeclaration: VariableDeclaration,
		VariableDeclarator: VariableDeclarator,
		WhileStatement: LoopStatement
	};

	function wrap ( raw, parent ) {
		if ( Array.isArray( raw ) ) {
			return raw.map( function ( value ) { return wrap( value, parent ); } );
		}

		if ( raw && typeof raw === 'object' ) {
			if ( raw.type === 'BlockStatement' ) return new BlockStatement( raw, parent );

			var Constructor = types[ raw.type ] || Node;
			return new Constructor( raw, parent );
		}

		return raw; // scalar value
	}

	var letConst = /^(?:let|const)$/;

	function Scope ( options ) {
		options = options || {};

		this.parent = options.parent;
		this.isBlockScope = !!options.block;

		var scope = this;
		while ( scope.isBlockScope ) scope = scope.parent;
		this.functionScope = scope;

		this.declarations = Object.create( null );
		this.references = Object.create( null );
		this.blockScopedDeclarations = this.isBlockScope ? null : Object.create( null );
		this.aliases = this.isBlockScope ? null : Object.create( null );
	}

	Scope.prototype = {
		addDeclaration: function addDeclaration ( node, kind ) {
			for ( var i = 0, list = extractNames( node ); i < list.length; i += 1 ) {
				var name = list[i];

				var existingDeclaration = this.declarations[ name ];
				if ( existingDeclaration && ( letConst.test( kind ) || letConst.test( existingDeclaration.kind ) ) ) {
					// TODO warn about double var declarations?
					throw new CompileError( node, ("" + name + " is already declared") );
				}

				var declaration = { name: name, node: node, kind: kind, instances: [] };
				this.declarations[ name ] = declaration;

				if ( this.isBlockScope ) {
					if ( !this.functionScope.blockScopedDeclarations[ name ] ) this.functionScope.blockScopedDeclarations[ name ] = [];
					this.functionScope.blockScopedDeclarations[ name ].push( declaration );
				}
			}
		},

		addReference: function addReference ( identifier ) {
			var declaration = this.declarations[ identifier.name ];
			if ( declaration ) {
				declaration.instances.push( identifier );
			} else {
				this.references[ identifier.name ] = true;
				if ( this.parent ) this.parent.addReference( identifier );
			}
		},

		contains: function contains ( name ) {
			return this.declarations[ name ] ||
			       ( this.parent ? this.parent.contains( name ) : false );
		},

		createIdentifier: function createIdentifier ( base ) {
			var this$1 = this;

			var name = base;
			var counter = 1;

			while ( this$1.declarations[ name ] || this$1.references[ name ] || this$1.aliases[ name ] || name in reserved ) {
				name = "" + base + "$" + (counter++);
			}

			this.aliases[ name ] = true;
			return name;
		},

		findDeclaration: function findDeclaration ( name ) {
			return this.declarations[ name ] ||
			       ( this.parent && this.parent.findDeclaration( name ) );
		}
	};

	var BlockStatement = (function (Node) {
		function BlockStatement () {
			Node.apply(this, arguments);
		}

		BlockStatement.prototype = Object.create( Node && Node.prototype );
		BlockStatement.prototype.constructor = BlockStatement;

		BlockStatement.prototype.createScope = function createScope () {
			var this$1 = this;

			this.parentIsFunction = /Function/.test( this.parent.type );
			this.isFunctionBlock = this.parentIsFunction || this.parent.type === 'Root';
			this.scope = new Scope({
				block: !this.isFunctionBlock,
				parent: this.parent.findScope( false )
			});

			if ( this.parentIsFunction ) {
				this.parent.params.forEach( function ( node ) {
					this$1.scope.addDeclaration( node, 'param' );
				});
			}
		};

		BlockStatement.prototype.initialise = function initialise ( transforms ) {
			this.thisAlias = null;
			this.argumentsAlias = null;
			this.defaultParameters = [];

			// normally the scope gets created here, during initialisation,
			// but in some cases (e.g. `for` statements), we need to create
			// the scope early, as it pertains to both the init block and
			// the body of the statement
			if ( !this.scope ) this.createScope();

			this.body.forEach( function ( node ) { return node.initialise( transforms ); } );
		};

		BlockStatement.prototype.findLexicalBoundary = function findLexicalBoundary () {
			if ( this.type === 'Program' ) return this;
			if ( /^Function/.test( this.parent.type ) ) return this;

			return this.parent.findLexicalBoundary();
		};

		BlockStatement.prototype.findScope = function findScope ( functionScope ) {
			if ( functionScope && !this.isFunctionBlock ) return this.parent.findScope( functionScope );
			return this.scope;
		};

		BlockStatement.prototype.getArgumentsAlias = function getArgumentsAlias () {
			if ( !this.argumentsAlias ) {
				this.argumentsAlias = this.scope.createIdentifier( 'arguments' );
			}

			return this.argumentsAlias;
		};

		BlockStatement.prototype.getThisAlias = function getThisAlias () {
			if ( !this.thisAlias ) {
				this.thisAlias = this.scope.createIdentifier( 'this' );
			}

			return this.thisAlias;
		};

		BlockStatement.prototype.transpile = function transpile ( code, transforms ) {
			var this$1 = this;

			var start = this.body[0] ? this.body[0].start : this.start + 1;

			var indentation = this.synthetic ?
				this.getIndentation() + code.getIndentString() :
				( this.body.length ? this.body[0].getIndentation() : '' );

			var addedStuff = false;

			if ( this.argumentsAlias ) {
				var assignment = "var " + (this.argumentsAlias) + " = arguments;";
				code.insert( start, assignment );
				addedStuff = true;
			}

			if ( this.thisAlias ) {
				if ( addedStuff ) code.insert( start, ("\n" + indentation) );
				var assignment$1 = "var " + (this.thisAlias) + " = this;";
				code.insert( start, assignment$1 );
				addedStuff = true;
			}

			if ( /Function/.test( this.parent.type ) ) {
				var params = this.parent.params;

				// default parameters
				if ( transforms.defaultParameter ) {
					params.filter( function ( param ) { return param.type === 'AssignmentPattern'; } ).forEach( function ( param ) {
						if ( addedStuff ) code.insert( start, ("\n" + indentation) );

						var lhs = "if ( " + (param.left.name) + " === void 0 ) " + (param.left.name);
						code
							.insert( start, ("" + lhs) )
							.move( param.left.end, param.right.end, start )
							.insert( start, (";") );

						addedStuff = true;
					});
				}

				// object pattern
				if ( transforms.parameterDestructuring ) {
					params.filter( function ( param ) { return param.type === 'ObjectPattern'; } ).forEach( function ( param ) {
						var ref = this$1.scope.createIdentifier( 'ref' );
						code.insert( param.start, ref );

						var lastIndex = param.start;

						param.properties.forEach( function ( prop ) {
							code.remove( lastIndex, prop.value.start );

							if ( addedStuff ) code.insert( start, ("\n" + indentation) );

							var key = prop.key.name;

							if ( prop.value.type === 'Identifier' ) {
								code.remove( prop.value.start, prop.value.end );
								lastIndex = prop.value.end;

								var value = prop.value.name;
								code.insert( start, ("var " + value + " = " + ref + "." + key + ";") );
							} else if ( prop.value.type === 'AssignmentPattern' ) {
								code.remove( prop.value.start, prop.value.right.start );
								lastIndex = prop.value.right.end;

								var value$1 = prop.value.left.name;
								code
									.insert( start, ("var " + ref + "_" + key + " = " + ref + "." + key + ", " + value$1 + " = " + ref + "_" + key + " === void 0 ? ") )
									.move( prop.value.right.start, prop.value.right.end, start )
									.insert( start, (" : " + ref + "_" + key + ";") );
							}

							else {
								throw new CompileError( prop, ("Compound destructuring is not supported") );
							}

							addedStuff = true;
							lastIndex = prop.end;
						});

						code.remove( lastIndex, param.end );
					});

					// array pattern. TODO dry this out
					params.filter( function ( param ) { return param.type === 'ArrayPattern'; } ).forEach( function ( param ) {
						var ref = this$1.scope.createIdentifier( 'ref' );
						code.insert( param.start, ref );

						var lastIndex = param.start;

						param.elements.forEach( function ( element, i ) {
							code.remove( lastIndex, element.start );

							if ( addedStuff ) code.insert( start, ("\n" + indentation) );

							if ( element.type === 'Identifier' ) {
								code.remove( element.start, element.end );
								lastIndex = element.end;

								code.insert( start, ("var " + (element.name) + " = " + ref + "[" + i + "];") );
							} else if ( element.type === 'AssignmentPattern' ) {
								code.remove( element.start, element.right.start );
								lastIndex = element.right.end;

								var name = element.left.name;
								code
									.insert( start, ("var " + ref + "_" + i + " = ref[" + i + "], " + name + " = ref_" + i + " === void 0 ? ") )
									.move( element.right.start, element.right.end, start )
									.insert( start, (" : ref_" + i + ";") );
							}

							else {
								throw new CompileError( element, ("Compound destructuring is not supported") );
							}

							addedStuff = true;
							lastIndex = element.end;
						});

						code.remove( lastIndex, param.end );
					});
				}

				// rest parameter
				if ( transforms.spreadRest ) {
					var lastParam = params[ params.length - 1 ];
					if ( lastParam && lastParam.type === 'RestElement' ) {
						var penultimateParam = params[ params.length - 2 ];

						if ( penultimateParam ) {
							code.remove( penultimateParam ? penultimateParam.end : lastParam.start, lastParam.end );
						} else {
							var start$1 = lastParam.start, end = lastParam.end; // TODO https://gitlab.com/Rich-Harris/buble/issues/8

							while ( /\s/.test( code.original[ start$1 - 1 ] ) ) start$1 -= 1;
							while ( /\s/.test( code.original[ end ] ) ) end += 1;

							code.remove( start$1, end );
						}

						if ( addedStuff ) code.insert( start, ("\n" + indentation) );

						var name = lastParam.argument.name;
						var len = this.scope.createIdentifier( 'len' );
						var count = params.length - 1;

						if ( count ) {
							code.insert( start, ("var " + name + " = [], " + len + " = arguments.length - " + count + ";\n" + indentation + "while ( " + len + "-- > 0 ) " + name + "[ " + len + " ] = arguments[ " + len + " + " + count + " ];") );
						} else {
							code.insert( start, ("var " + name + " = [], " + len + " = arguments.length;\n" + indentation + "while ( " + len + "-- ) " + name + "[ " + len + " ] = arguments[ " + len + " ];") );
						}

						addedStuff = true;
					}
				}
			}

			if ( addedStuff ) {
				code.insert( start, ("\n\n" + indentation) );
			}

			if ( transforms.letConst && this.isFunctionBlock ) {
				Object.keys( this.scope.blockScopedDeclarations ).forEach( function ( name ) {
					var declarations = this$1.scope.blockScopedDeclarations[ name ];

					for ( var i = 0; i < declarations.length; i += 1 ) {
						var declaration = declarations[i];
						var cont = false; // TODO implement proper continue...

						if ( declaration.kind === 'for.let' ) {
							// special case
							var forStatement = declaration.node.findNearest( 'ForStatement' );

							if ( forStatement.shouldRewriteAsFunction ) {
								var outerAlias = this$1.scope.createIdentifier( name );
								var innerAlias = forStatement.reassigned[ name ] ?
									this$1.scope.createIdentifier( name ) :
									name;

								declaration.name = outerAlias;

								forStatement.aliases[ name ] = {
									outer: outerAlias,
									inner: innerAlias
								};

								for ( var i$1 = 0, list = declaration.instances; i$1 < list.length; i$1 += 1 ) {
									var identifier = list[i$1];

									var alias = forStatement.body.contains( identifier ) ?
										innerAlias :
										outerAlias;

									if ( name !== alias ) {
										code.overwrite( identifier.start, identifier.end, alias, true );
									}
								}

								cont = true;
							}
						}

						if ( !cont ) {
							var alias$1 = this$1.scope.createIdentifier( name );

							if ( name !== alias$1 ) {
								declaration.name = alias$1;

								for ( var i$2 = 0, list$1 = declaration.instances; i$2 < list$1.length; i$2 += 1 ) {
									var identifier$1 = list$1[i$2];

									code.overwrite( identifier$1.start, identifier$1.end, alias$1, true );
								}
							}
						}
					}
				});
			}

			if ( this.synthetic && this.parent.type === 'ArrowFunctionExpression' ) {
				code.insert( this.body[0].start, 'return ' );
			}

			Node.prototype.transpile.call( this, code, transforms );
		};

		return BlockStatement;
	}(Node));

	function Program ( source, ast, transforms ) {
		var this$1 = this;

		this.type = 'Root';

		this.source = source;
		this.magicString = new MagicString( source );

		this.ast = ast;
		this.depth = 0;

		this.body = new BlockStatement( ast, this );

		this.templateElements = [];
		this.body.initialise( transforms );

		this.indentExclusions = {};
		for ( var i$1 = 0, list = this.templateElements; i$1 < list.length; i$1 += 1 ) {
			var node = list[i$1];

			for ( var i = node.start; i < node.end; i += 1 ) {
				this$1.indentExclusions[ node.start + i ] = true;
			}
		}

		this.body.transpile( this.magicString, transforms );
	}

	Program.prototype = {
		export: function export$1 ( options ) {
			if ( options === void 0 ) options = {};

			return {
				code: this.magicString.toString(),
				map: this.magicString.generateMap({
					file: options.file,
					source: options.source,
					includeContent: options.includeContent !== false
				})
			};
		},

		findNearest: function findNearest () {
			return null;
		},

		findScope: function findScope () {
			return null;
		}
	};

	var matrix = {
		chrome: {
			    48: 1333689725,
			    49: 1342078975,
			    50: 1610514431
		},
		firefox: {
			    43: 1207307741,
			    44: 1207307741,
			    45: 1207307741
		},
		safari: {
			     8: 1073741824,
			     9: 1328940894
		},
		ie: {
			     8: 0,
			     9: 1073741824,
			    10: 1073741824,
			    11: 1073770592
		},
		edge: {
			    12: 1591620701,
			    13: 1608400479
		},
		node: {
			'0.10': 1075052608,
			'0.12': 1091830852,
			     4: 1327398527,
			     5: 1327398527
		}
	};

	var features = [
		'arrow',
		'classes',
		'collections',
		'computedProperty',
		'conciseMethodProperty',
		'constLoop',
		'constRedef',
		'defaultParameter',
		'destructuring',
		'extendNatives',
		'forOf',
		'generator',
		'letConst',
		'letLoop',
		'letLoopScope',
		'moduleExport',
		'moduleImport',
		'numericLiteral',
		'objectProto',
		'objectSuper',
		'oldOctalLiteral',
		'parameterDestructuring',
		'spreadRest',
		'stickyRegExp',
		'symbol',
		'templateString',
		'unicodeEscape',
		'unicodeIdentifier',
		'unicodeRegExp',

		// ES2016
		'exponentiation',

		// additional transforms, not from
		// https://featuretests.io
		'reservedProperties'
	];

	var version = "0.5.8";

	var dangerousTransforms = [
		'dangerousTaggedTemplateString',
		'dangerousForOf'
	];

	function target ( target ) {
		var targets = Object.keys( target );
		var bitmask = targets.length ?
			2147483647 :
			1073741824;

		Object.keys( target ).forEach( function ( environment ) {
			var versions = matrix[ environment ];
			if ( !versions ) throw new Error( ("Unknown environment '" + environment + "'. Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues") );

			var targetVersion = target[ environment ];
			if ( !( targetVersion in versions ) ) throw new Error( ("Support data exists for the following versions of " + environment + ": " + (Object.keys( versions ).join( ', ')) + ". Please raise an issue at https://gitlab.com/Rich-Harris/buble/issues") );
			var support = versions[ targetVersion ];

			bitmask &= support;
		});

		var transforms = Object.create( null );
		features.forEach( function ( name, i ) {
			transforms[ name ] = !( bitmask & 1 << i );
		});

		dangerousTransforms.forEach( function ( name ) {
			transforms[ name ] = false;
		});

		return transforms;
	}

	function transform ( source, options ) {
		if ( options === void 0 ) options = {};

		var ast;

		try {
			ast = acorn.parse( source, {
				ecmaVersion: 7,
				preserveParens: true,
				sourceType: 'module'
			});
		} catch ( err ) {
			err.snippet = getSnippet( source, err.loc );
			throw err;
		}

		var transforms = target( options.target || {} );
		Object.keys( options.transforms || {} ).forEach( function ( name ) {
			if ( name === 'modules' ) {
				if ( !( 'moduleImport' in options.transforms ) ) transforms.moduleImport = options.transforms.modules;
				if ( !( 'moduleExport' in options.transforms ) ) transforms.moduleExport = options.transforms.modules;
				return;
			}

			if ( !( name in transforms ) ) throw new Error( ("Unknown transform '" + name + "'") );
			transforms[ name ] = options.transforms[ name ];
		});

		return new Program( source, ast, transforms ).export( options );
	}

	exports.target = target;
	exports.transform = transform;
	exports.VERSION = version;

}));
//# sourceMappingURL=buble.umd.js.map