{"version":3,"file":"rollup.browser.js","sources":["../node_modules/es6-promise/lib/es6-promise/promise.js","../src/utils/path.js","../src/utils/fs.js","../src/utils/object.js","../src/utils/validateKeys.js","../src/utils/sourceMappingURL.js","../node_modules/vlq/src/vlq.js","../node_modules/magic-string/dist/magic-string.es6.js","../src/utils/first.js","../node_modules/acorn/src/identifier.js","../node_modules/acorn/src/tokentype.js","../node_modules/acorn/src/whitespace.js","../node_modules/acorn/src/util.js","../node_modules/acorn/src/locutil.js","../node_modules/acorn/src/options.js","../node_modules/acorn/src/state.js","../node_modules/acorn/src/parseutil.js","../node_modules/acorn/src/statement.js","../node_modules/acorn/src/lval.js","../node_modules/acorn/src/expression.js","../node_modules/acorn/src/location.js","../node_modules/acorn/src/node.js","../node_modules/acorn/src/tokencontext.js","../node_modules/acorn/src/tokenize.js","../node_modules/acorn/src/index.js","../node_modules/estree-walker/dist/estree-walker.es6.js","../src/ast/modifierNodes.js","../src/ast/isReference.js","../src/ast/flatten.js","../src/utils/pureFunctions.js","../src/utils/getLocation.js","../src/utils/error.js","../src/utils/run.js","../src/Reference.js","../src/Declaration.js","../src/ast/extractNames.js","../src/ast/Scope.js","../src/ast/attachScopes.js","../src/ast/isFunctionDeclaration.js","../src/Statement.js","../src/utils/makeLegalIdentifier.js","../src/ast/conditions.js","../src/ast/create.js","../src/Module.js","../src/ExternalModule.js","../src/utils/map-helpers.js","../src/finalisers/shared/getInteropBlock.js","../src/finalisers/shared/getExportBlock.js","../src/finalisers/shared/esModuleExport.js","../src/finalisers/amd.js","../src/finalisers/cjs.js","../src/finalisers/es6.js","../src/finalisers/shared/getGlobalNameMaker.js","../src/finalisers/iife.js","../src/finalisers/umd.js","../src/finalisers/index.js","../src/utils/ensureArray.js","../src/utils/defaults.js","../src/utils/getExportMode.js","../src/utils/getIndentString.js","../src/utils/normalizePlatform.js","../src/utils/promise.js","../src/utils/transform.js","../src/utils/transformBundle.js","../node_modules/sourcemap-codec/dist/sourcemap-codec.es6.js","../src/utils/collapseSourcemaps.js","../src/utils/callIfFunction.js","../src/Bundle.js","../src/rollup.js"],"sourcesContent":["export default window.Promise;\n","// TODO does this all work on windows?\n\nexport const absolutePath = /^(?:\\/|(?:[A-Za-z]:)?[\\\\|\\/])/;\nexport const relativePath = /^\\.?\\.\\//;\n\nexport function isAbsolute ( path ) {\n\treturn absolutePath.test( path );\n}\n\nexport function isRelative ( path ) {\n\treturn relativePath.test( path );\n}\n\nexport function basename ( path ) {\n\treturn path.split( /(\\/|\\\\)/ ).pop();\n}\n\nexport function dirname ( path ) {\n\tconst match = /(\\/|\\\\)[^\\/\\\\]*$/.exec( path );\n\tif ( !match ) return '.';\n\n\tconst dir = path.slice( 0, -match[0].length );\n\n\t// If `dir` is the empty string, we're at root.\n\treturn dir ? dir : '/';\n}\n\nexport function extname ( path ) {\n\tconst match = /\\.[^\\.]+$/.exec( basename( path ) );\n\tif ( !match ) return '';\n\treturn match[0];\n}\n\nexport function relative ( from, to ) {\n\tconst fromParts = from.split( /[\\/\\\\]/ ).filter( Boolean );\n\tconst toParts = to.split( /[\\/\\\\]/ ).filter( Boolean );\n\n\twhile ( fromParts[0] && toParts[0] && fromParts[0] === toParts[0] ) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\twhile ( toParts[0] === '.' || toParts[0] === '..' ) {\n\t\tconst toPart = toParts.shift();\n\t\tif ( toPart === '..' ) {\n\t\t\tfromParts.pop();\n\t\t}\n\t}\n\n\twhile ( fromParts.pop() ) {\n\t\ttoParts.unshift( '..' );\n\t}\n\n\treturn toParts.join( '/' );\n}\n\nexport function resolve ( ...paths ) {\n\tlet resolvedParts = paths.shift().split( /[\\/\\\\]/ );\n\n\tpaths.forEach( path => {\n\t\tif ( isAbsolute( path ) ) {\n\t\t\tresolvedParts = path.split( /[\\/\\\\]/ );\n\t\t} else {\n\t\t\tconst parts = path.split( /[\\/\\\\]/ );\n\n\t\t\twhile ( parts[0] === '.' || parts[0] === '..' ) {\n\t\t\t\tconst part = parts.shift();\n\t\t\t\tif ( part === '..' ) {\n\t\t\t\t\tresolvedParts.pop();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolvedParts.push.apply( resolvedParts, parts );\n\t\t}\n\t});\n\n\treturn resolvedParts.join( '/' ); // TODO windows...\n}\n","const nope = method => `Cannot use fs.${method} inside browser`;\n\nexport const isFile = () => false;\nexport const readdirSync = nope( 'readdirSync' );\nexport const readFileSync = nope( 'readFileSync' );\nexport const writeFile = nope( 'writeFile' );\n","export const { keys } = Object;\n\nexport function blank () {\n\treturn Object.create( null );\n}\n\nexport function forOwn ( object, func ) {\n\tObject.keys( object ).forEach( key => func( object[ key ], key ) );\n}\n","import { keys } from './object.js';\n\nexport default function validateKeys ( object, allowedKeys ) {\n\tconst actualKeys = keys( object );\n\n\tlet i = actualKeys.length;\n\n\twhile ( i-- ) {\n\t\tconst key = actualKeys[i];\n\n\t\tif ( allowedKeys.indexOf( key ) === -1 ) {\n\t\t\treturn new Error(\n\t\t\t\t`Unexpected key '${ key }' found, expected one of: ${ allowedKeys.join( ', ' ) }`\n\t\t\t);\n\t\t}\n\t}\n}\n","// this looks ridiculous, but it prevents sourcemap tooling from mistaking\n// this for an actual sourceMappingURL\nlet SOURCEMAPPING_URL = 'sourceMa';\nSOURCEMAPPING_URL += 'ppingURL';\n\nexport default SOURCEMAPPING_URL;\n","var charToInteger = {};\nvar integerToChar = {};\n\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split( '' ).forEach( function ( char, i ) {\n\tcharToInteger[ char ] = i;\n\tintegerToChar[ i ] = char;\n});\n\nexport function decode ( string ) {\n\tvar result = [],\n\t\tlen = string.length,\n\t\ti,\n\t\thasContinuationBit,\n\t\tshift = 0,\n\t\tvalue = 0,\n\t\tinteger,\n\t\tshouldNegate;\n\n\tfor ( i = 0; i < len; i += 1 ) {\n\t\tinteger = charToInteger[ string[i] ];\n\n\t\tif ( integer === undefined ) {\n\t\t\tthrow new Error( 'Invalid character (' + string[i] + ')' );\n\t\t}\n\n\t\thasContinuationBit = integer & 32;\n\n\t\tinteger &= 31;\n\t\tvalue += integer << shift;\n\n\t\tif ( hasContinuationBit ) {\n\t\t\tshift += 5;\n\t\t} else {\n\t\t\tshouldNegate = value & 1;\n\t\t\tvalue >>= 1;\n\n\t\t\tresult.push( shouldNegate ? -value : value );\n\n\t\t\t// reset\n\t\t\tvalue = shift = 0;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function encode ( value ) {\n\tvar result, i;\n\n\tif ( typeof value === 'number' ) {\n\t\tresult = encodeInteger( value );\n\t} else {\n\t\tresult = '';\n\t\tfor ( i = 0; i < value.length; i += 1 ) {\n\t\t\tresult += encodeInteger( value[i] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction encodeInteger ( num ) {\n\tvar result = '', clamped;\n\n\tif ( num < 0 ) {\n\t\tnum = ( -num << 1 ) | 1;\n\t} else {\n\t\tnum <<= 1;\n\t}\n\n\tdo {\n\t\tclamped = num & 31;\n\t\tnum >>= 5;\n\n\t\tif ( num > 0 ) {\n\t\t\tclamped |= 32;\n\t\t}\n\n\t\tresult += integerToChar[ clamped ];\n\t} while ( num > 0 );\n\n\treturn result;\n}\n","import { encode } from 'vlq';\n\nfunction Patch(start, end, content, original, storeName) {\n\tthis.start = start;\n\tthis.end = end;\n\tthis.content = content;\n\tthis.original = original;\n\tthis.storeName = storeName;\n}\n\nPatch.prototype = {\n\tclone: function clone() {\n\t\treturn new Patch(this.start, this.end, this.content, this.original, this.storeName);\n\t}\n};\n\nvar _btoa = undefined;\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n\t_btoa = window.btoa;\n} else if (typeof Buffer === 'function') {\n\t/* global Buffer */\n\t_btoa = function (str) {\n\t\treturn new Buffer(str).toString('base64');\n\t};\n} else {\n\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n}\n\nvar btoa = _btoa;\n\nfunction SourceMap(properties) {\n\tthis.version = 3;\n\n\tthis.file = properties.file;\n\tthis.sources = properties.sources;\n\tthis.sourcesContent = properties.sourcesContent;\n\tthis.names = properties.names;\n\tthis.mappings = properties.mappings;\n}\n\nSourceMap.prototype = {\n\ttoString: function toString() {\n\t\treturn JSON.stringify(this);\n\t},\n\ttoUrl: function toUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n};\n\nfunction guessIndent(code) {\n\tvar lines = code.split('\\n');\n\n\tvar tabbed = lines.filter(function (line) {\n\t\treturn (/^\\t+/.test(line)\n\t\t);\n\t});\n\tvar spaced = lines.filter(function (line) {\n\t\treturn (/^ {2,}/.test(line)\n\t\t);\n\t});\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tvar min = spaced.reduce(function (previous, current) {\n\t\tvar numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n\nfunction encodeMappings(original, intro, patches, hires, sourcemapLocations, sourceIndex, offsets, names) {\n\tvar rawLines = [];\n\n\tvar generatedCodeLine = intro.split('\\n').length - 1;\n\tvar rawSegments = rawLines[generatedCodeLine] = [];\n\n\tvar originalCharIndex = 0;\n\n\tvar generatedCodeColumn = 0;\n\tvar sourceCodeLine = 0;\n\tvar sourceCodeColumn = 0;\n\n\tfunction addSegmentsUntil(end) {\n\t\tvar first = true;\n\n\t\twhile (originalCharIndex < end) {\n\t\t\tif (hires || first || sourcemapLocations[originalCharIndex]) {\n\t\t\t\trawSegments.push({\n\t\t\t\t\tgeneratedCodeLine: generatedCodeLine,\n\t\t\t\t\tgeneratedCodeColumn: generatedCodeColumn,\n\t\t\t\t\tsourceCodeLine: sourceCodeLine,\n\t\t\t\t\tsourceCodeColumn: sourceCodeColumn,\n\t\t\t\t\tsourceCodeName: -1,\n\t\t\t\t\tsourceIndex: sourceIndex\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tsourceCodeLine += 1;\n\t\t\t\tsourceCodeColumn = 0;\n\t\t\t\tgeneratedCodeLine += 1;\n\t\t\t\trawLines[generatedCodeLine] = rawSegments = [];\n\t\t\t\tgeneratedCodeColumn = 0;\n\t\t\t} else {\n\t\t\t\tsourceCodeColumn += 1;\n\t\t\t\tgeneratedCodeColumn += 1;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t\tfirst = false;\n\t\t}\n\t}\n\n\tfor (var i = 0; i < patches.length; i += 1) {\n\t\tvar patch = patches[i];\n\t\tvar addSegmentForPatch = patch.storeName || patch.start > originalCharIndex;\n\n\t\taddSegmentsUntil(patch.start);\n\n\t\tif (addSegmentForPatch) {\n\t\t\trawSegments.push({\n\t\t\t\tgeneratedCodeLine: generatedCodeLine,\n\t\t\t\tgeneratedCodeColumn: generatedCodeColumn,\n\t\t\t\tsourceCodeLine: sourceCodeLine,\n\t\t\t\tsourceCodeColumn: sourceCodeColumn,\n\t\t\t\tsourceCodeName: patch.storeName ? names.indexOf(patch.original) : -1,\n\t\t\t\tsourceIndex: sourceIndex\n\t\t\t});\n\t\t}\n\n\t\tvar lines = patch.content.split('\\n');\n\t\tvar lastLine = lines.pop();\n\n\t\tif (lines.length) {\n\t\t\tgeneratedCodeLine += lines.length;\n\t\t\trawLines[generatedCodeLine] = rawSegments = [];\n\t\t\tgeneratedCodeColumn = lastLine.length;\n\t\t} else {\n\t\t\tgeneratedCodeColumn += lastLine.length;\n\t\t}\n\n\t\tlines = patch.original.split('\\n');\n\t\tlastLine = lines.pop();\n\n\t\tif (lines.length) {\n\t\t\tsourceCodeLine += lines.length;\n\t\t\tsourceCodeColumn = lastLine.length;\n\t\t} else {\n\t\t\tsourceCodeColumn += lastLine.length;\n\t\t}\n\n\t\toriginalCharIndex = patch.end;\n\t}\n\n\taddSegmentsUntil(original.length);\n\n\toffsets.sourceIndex = offsets.sourceIndex || 0;\n\toffsets.sourceCodeLine = offsets.sourceCodeLine || 0;\n\toffsets.sourceCodeColumn = offsets.sourceCodeColumn || 0;\n\toffsets.sourceCodeName = offsets.sourceCodeName || 0;\n\n\tvar encoded = rawLines.map(function (segments) {\n\t\tvar generatedCodeColumn = 0;\n\n\t\treturn segments.map(function (segment) {\n\t\t\tvar arr = [segment.generatedCodeColumn - generatedCodeColumn, segment.sourceIndex - offsets.sourceIndex, segment.sourceCodeLine - offsets.sourceCodeLine, segment.sourceCodeColumn - offsets.sourceCodeColumn];\n\n\t\t\tgeneratedCodeColumn = segment.generatedCodeColumn;\n\t\t\toffsets.sourceIndex = segment.sourceIndex;\n\t\t\toffsets.sourceCodeLine = segment.sourceCodeLine;\n\t\t\toffsets.sourceCodeColumn = segment.sourceCodeColumn;\n\n\t\t\tif (~segment.sourceCodeName) {\n\t\t\t\tarr.push(segment.sourceCodeName - offsets.sourceCodeName);\n\t\t\t\toffsets.sourceCodeName = segment.sourceCodeName;\n\t\t\t}\n\n\t\t\treturn encode(arr);\n\t\t}).join(',');\n\t}).join(';');\n\n\treturn encoded;\n}\n\nfunction getRelativePath(from, to) {\n\tvar fromParts = from.split(/[\\/\\\\]/);\n\tvar toParts = to.split(/[\\/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tvar i = fromParts.length;\n\t\twhile (i--) {\n\t\t\tfromParts[i] = '..';\n\t\t}\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n\nvar toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n\nvar warned = false;\n\nfunction MagicString(string) {\n\tvar options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\tObject.defineProperties(this, {\n\t\toriginal: { writable: true, value: string },\n\t\toutro: { writable: true, value: '' },\n\t\tintro: { writable: true, value: '' },\n\t\tpatches: { writable: true, value: [] },\n\t\tfilename: { writable: true, value: options.filename },\n\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\tsourcemapLocations: { writable: true, value: {} },\n\t\tstoredNames: { writable: true, value: {} },\n\t\tindentStr: { writable: true, value: guessIndent(string) }\n\t});\n}\n\nMagicString.prototype = {\n\taddSourcemapLocation: function addSourcemapLocation(char) {\n\t\tthis.sourcemapLocations[char] = true;\n\t},\n\tappend: function append(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t},\n\tclone: function clone() {\n\t\tvar cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tcloned.patches = this.patches.map(function (patch) {\n\t\t\treturn patch.clone();\n\t\t});\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = typeof this.indentExclusionRanges[0] === 'number' ? [this.indentExclusionRanges[0], this.indentExclusionRanges[1]] : this.indentExclusionRanges.map(function (range) {\n\t\t\t\treturn [range.start, range.end];\n\t\t\t});\n\t\t}\n\n\t\tObject.keys(this.sourcemapLocations).forEach(function (loc) {\n\t\t\tcloned.sourcemapLocations[loc] = true;\n\t\t});\n\n\t\treturn cloned;\n\t},\n\tgenerateMap: function generateMap(options) {\n\t\toptions = options || {};\n\n\t\tvar names = Object.keys(this.storedNames);\n\n\t\treturn new SourceMap({\n\t\t\tfile: options.file ? options.file.split(/[\\/\\\\]/).pop() : null,\n\t\t\tsources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : [null],\n\t\t\tnames: names,\n\t\t\tmappings: this.getMappings(options.hires, 0, {}, names)\n\t\t});\n\t},\n\tgetIndentString: function getIndentString() {\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t},\n\tgetMappings: function getMappings(hires, sourceIndex, offsets, names) {\n\t\treturn encodeMappings(this.original, this.intro, this.patches, hires, this.sourcemapLocations, sourceIndex, offsets, names);\n\t},\n\tindent: function indent(indentStr, options) {\n\t\tvar _this = this;\n\n\t\tvar pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tindentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tvar isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tvar exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach(function (exclusion) {\n\t\t\t\tfor (var i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar shouldIndentNextCharacter = options.indentStart !== false;\n\t\tvar replacer = function replacer(match) {\n\t\t\tif (shouldIndentNextCharacter) return '' + indentStr + match;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tvar charIndex = 0;\n\t\tvar patchIndex = 0;\n\n\t\tvar indentUntil = function indentUntil(end) {\n\t\t\twhile (charIndex < end) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tvar char = _this.original[charIndex];\n\n\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t_this.patches.splice(patchIndex, 0, new Patch(charIndex, charIndex, indentStr, '', false));\n\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\tpatchIndex += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcharIndex += 1;\n\t\t\t}\n\t\t};\n\n\t\tfor (; patchIndex < this.patches.length; patchIndex += 1) {\n\t\t\t// can't cache this.patches.length, it may change\n\t\t\tvar patch = this.patches[patchIndex];\n\n\t\t\tindentUntil(patch.start);\n\n\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\tpatch.content = patch.content.replace(pattern, replacer);\n\n\t\t\t\tif (patch.content.length) {\n\t\t\t\t\tshouldIndentNextCharacter = patch.content[patch.content.length - 1] === '\\n';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = patch.end;